package pgsql

import (
	"database/sql"
	"encoding/json"
	"fmt"

	"github.com/pkg/errors"
	"github.com/stackrox/scanner/pkg/component"
)

func (pgSQL *pgSQL) InsertLayerComponents(layerName string, c []*component.Component) error {
	// todo(cgorman) evaluate if we should hash marshalled component bytes and do lookups instead

	insertedLayer, err := pgSQL.FindLayer(layerName, false, false)
	if err != nil {
		return err
	}

	data, err := json.Marshal(c)
	if err != nil {
		return err
	}

	_, err = pgSQL.Exec(`INSERT INTO LanguageLayer(layer_id, layer_name, component_data)
	VALUES ($1, $2, $3); `, insertedLayer.ID, insertedLayer.Name, data)
	return err
}

func parseComponentData(rows *sql.Rows) (string, []*component.Component, error) {
	var (
		layerName string
		data      []byte
	)
	if err := rows.Scan(&layerName, &data); err != nil {
		return "", nil, err
	}
	var components []*component.Component
	if err := json.Unmarshal(data, &components); err != nil {
		return "", nil, err
	}
	return layerName, components, nil
}

func (pgSQL *pgSQL) GetLayerLanguageComponents(layer string) (map[string][]*component.Component, error) {
	rows, err := pgSQL.Query(searchLanguageComponentsInImage, layer)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	if !rows.Next() {
		return nil, fmt.Errorf("could not find layer %q for language components", layer)
	}

	components := make(map[string][]*component.Component)

	layerName, layerComponents, err := parseComponentData(rows)
	if err != nil {
		return nil, errors.Wrapf(err, "error parsing component data for %q", layer)
	}
	components[layerName] = layerComponents

	for rows.Next() {
		layerName, layerComponents, err := parseComponentData(rows)
		if err != nil {
			return nil, errors.Wrapf(err, "error parsing component data for %q", layer)
		}
		components[layerName] = layerComponents
	}
	return components, nil
}
