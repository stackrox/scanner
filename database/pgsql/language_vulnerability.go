package pgsql

import (
	"database/sql"
	"encoding/json"
	"fmt"

	"github.com/lib/pq"
	"github.com/pkg/errors"
	"github.com/stackrox/scanner/database"
	"github.com/stackrox/scanner/pkg/component"
	"github.com/stackrox/scanner/pkg/rhel"
)

func (pgSQL *pgSQL) InsertLayerComponents(layer, lineage string, c []*component.Component, r []string, opts *database.DatastoreOptions) error {
	insertedLayer, err := pgSQL.FindLayer(layer, lineage, &database.DatastoreOptions{
		UncertifiedRHEL: opts.GetUncertifiedRHEL(),
	})
	if err != nil {
		return err
	}

	data, err := json.Marshal(c)
	if err != nil {
		return err
	}

	if opts.GetUncertifiedRHEL() {
		insertedLayer.Name = rhel.GetUncertifiedLayerName(insertedLayer.Name)
	}

	_, err = pgSQL.Exec(`INSERT INTO LanguageLayer(layer_id, layer_name, lineage, component_data, removed_components)
	VALUES ($1, $2, $3, $4, $5) ON CONFLICT DO NOTHING;`, insertedLayer.ID, insertedLayer.Name, lineage, data, pq.Array(r))
	return err
}

func parseComponentData(rows *sql.Rows, uncertifiedRHEL bool) (*component.LayerToComponents, error) {
	var (
		layerName         string
		data              []byte
		removedComponents []string
	)
	if err := rows.Scan(&layerName, &data, pq.Array(&removedComponents)); err != nil {
		return nil, err
	}
	var components []*component.Component
	if err := json.Unmarshal(data, &components); err != nil {
		return nil, err
	}
	if uncertifiedRHEL {
		layerName = rhel.GetOriginalLayerName(layerName)
	}
	return &component.LayerToComponents{
		Layer:      layerName,
		Components: components,
		Removed:    removedComponents,
	}, nil
}

func (pgSQL *pgSQL) GetLayerLanguageComponents(layer, lineage string, opts *database.DatastoreOptions) ([]*component.LayerToComponents, error) {
	uncertifiedRHEL := opts.GetUncertifiedRHEL()

	if uncertifiedRHEL {
		layer = rhel.GetUncertifiedLayerName(layer)
	}

	rows, err := pgSQL.Query(searchLanguageComponentsInImage, layer, lineage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	if !rows.Next() {
		return nil, fmt.Errorf("could not find layer %q for language components", layer)
	}

	layerToComponent, err := parseComponentData(rows, uncertifiedRHEL)
	if err != nil {
		return nil, errors.Wrapf(err, "error parsing component data for %q", layer)
	}

	layersToComponents := []*component.LayerToComponents{
		layerToComponent,
	}

	for rows.Next() {
		layerToComponent, err := parseComponentData(rows, uncertifiedRHEL)
		if err != nil {
			return nil, errors.Wrapf(err, "error parsing component data for %q", layer)
		}
		layersToComponents = append(layersToComponents, layerToComponent)
	}
	return layersToComponents, nil
}
