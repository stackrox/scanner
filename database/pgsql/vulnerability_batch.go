package pgsql

import (
	"database/sql"
	"os"
	"reflect"
	"strconv"

	log "github.com/sirupsen/logrus"
	"github.com/stackrox/scanner/database"
	"github.com/stackrox/scanner/ext/versionfmt"
	"github.com/stackrox/scanner/pkg/commonerr"
)

const (
	// batchInsertEnvVar Environment variable to enable batched vulnerability inserts (CI mode)
	batchInsertEnvVar = "SCANNER_BATCH_INSERT"
	// defaultBatchSize Default batch size for bulk inserts
	defaultBatchSize = 1000
)

// shouldUseBatchInsert determines if batched inserts should be used based on environment variable.
// This is intended for CI environments where we're loading into an empty database.
func shouldUseBatchInsert() bool {
	value := os.Getenv(batchInsertEnvVar)
	return value == "true" || value == "1"
}

// getBatchSize returns the batch size from environment or default.
func getBatchSize() int {
	if sizeStr := os.Getenv("SCANNER_BATCH_SIZE"); sizeStr != "" {
		if size, err := strconv.Atoi(sizeStr); err == nil && size > 0 {
			return size
		}
	}
	return defaultBatchSize
}

// insertVulnerabilitiesBatched inserts vulnerabilities in batches using a single transaction per batch.
// This is significantly faster for bulk loading scenarios (like CI) where the database is empty
// and we don't need to handle complex merge logic.
//
// IMPORTANT: This optimization is only safe when:
// 1. Loading into an empty database (no existing vulnerabilities to merge)
// 2. All vulnerabilities are new inserts (not updates)
// 3. The SCANNER_BATCH_INSERT environment variable is explicitly set
func (pgSQL *pgSQL) insertVulnerabilitiesBatched(vulnerabilities []database.Vulnerability) error {
	batchSize := getBatchSize()
	totalVulns := len(vulnerabilities)

	log.WithFields(log.Fields{
		"total":      totalVulns,
		"batch_size": batchSize,
	}).Info("Using batched vulnerability inserts (CI mode)")

	for batchStart := 0; batchStart < totalVulns; batchStart += batchSize {
		batchEnd := batchStart + batchSize
		if batchEnd > totalVulns {
			batchEnd = totalVulns
		}

		batch := vulnerabilities[batchStart:batchEnd]

		if err := pgSQL.insertVulnerabilityBatch(batch); err != nil {
			return err
		}

		if (batchEnd)%printEveryWhenInsertingVulns == 0 {
			log.Infof("Inserted %d/%d vulns (batched)", batchEnd, totalVulns)
		}
	}

	return nil
}

// insertVulnerabilityBatch inserts a batch of vulnerabilities within a single transaction.
// This reuses the existing insertVulnerability logic but amortizes transaction overhead
// across multiple vulnerabilities.
func (pgSQL *pgSQL) insertVulnerabilityBatch(batch []database.Vulnerability) error {
	// Begin a single transaction for the entire batch
	tx, err := pgSQL.Begin()
	if err != nil {
		return handleError("insertVulnerabilityBatch.Begin()", err)
	}

	// Process each vulnerability using existing logic, but within the shared transaction
	for i := range batch {
		// We use the existing insertVulnerability logic, but we need to work around
		// the fact that it creates its own transaction. The approach is to inline
		// the core logic here.
		if err := pgSQL.insertSingleVulnerabilityInTx(tx, batch[i]); err != nil {
			tx.Rollback()
			return err
		}
	}

	// Commit the entire batch at once
	if err := tx.Commit(); err != nil {
		tx.Rollback()
		return handleError("insertVulnerabilityBatch.Commit()", err)
	}

	return nil
}

// insertSingleVulnerabilityInTx inserts a single vulnerability within an existing transaction.
// This is the core logic from insertVulnerability, but adapted to work with an externally-managed transaction.
func (pgSQL *pgSQL) insertSingleVulnerabilityInTx(tx *sql.Tx, vulnerability database.Vulnerability) error {
	// Verify parameters
	if vulnerability.Name == "" || vulnerability.Namespace.Name == "" {
		return commonerr.NewBadRequestError("insertVulnerability needs at least the Name and the Namespace")
	}

	// Validate FixedIn namespaces
	for i := 0; i < len(vulnerability.FixedIn); i++ {
		fifv := &vulnerability.FixedIn[i]
		if fifv.Feature.Namespace.Name == "" {
			fifv.Feature.Namespace = vulnerability.Namespace
		} else if fifv.Feature.Namespace.Name != vulnerability.Namespace.Name {
			msg := "could not insert an invalid vulnerability that contains FixedIn FeatureVersion that are not in the same namespace as the Vulnerability"
			log.Warning(msg)
			return commonerr.NewBadRequestError(msg)
		}
	}

	// Find existing vulnerability (for update case)
	existingVulnerability, err := findVulnerability(tx, vulnerability.Namespace.Name, vulnerability.Name, true)
	if err != nil && err != commonerr.ErrNotFound {
		return err
	}

	// Handle update case (merge with existing)
	if existingVulnerability.ID != 0 {
		updateMetadata := vulnerability.Description != existingVulnerability.Description ||
			vulnerability.Link != existingVulnerability.Link ||
			vulnerability.Severity != existingVulnerability.Severity ||
			!reflect.DeepEqual(castMetadata(vulnerability.Metadata), existingVulnerability.Metadata)

		var updateFixedIn bool
		vulnerability.FixedIn, updateFixedIn = applyFixedInDiff(existingVulnerability.FixedIn, vulnerability.FixedIn)

		if !updateMetadata && !updateFixedIn {
			// No changes needed
			return nil
		}

		// Mark old vulnerability as non-latest
		_, err = tx.Exec(removeVulnerability, vulnerability.Namespace.Name, vulnerability.Name)
		if err != nil {
			return handleError("removeVulnerability", err)
		}
	} else {
		// New vulnerability - remove MinVersion entries
		var fixedIn []database.FeatureVersion
		for _, fv := range vulnerability.FixedIn {
			if fv.Version != versionfmt.MinVersion {
				fixedIn = append(fixedIn, fv)
			}
		}
		vulnerability.FixedIn = fixedIn
	}

	// Find or insert namespace
	namespaceID, err := pgSQL.insertNamespace(vulnerability.Namespace)
	if err != nil {
		return err
	}

	// Insert vulnerability
	err = tx.QueryRow(
		insertVulnerability,
		namespaceID,
		vulnerability.Name,
		vulnerability.Description,
		vulnerability.Link,
		&vulnerability.Severity,
		&vulnerability.Metadata,
	).Scan(&vulnerability.ID)
	if err != nil {
		return handleError("insertVulnerability", err)
	}

	// Insert FixedIn feature versions
	err = pgSQL.insertVulnerabilityFixedInFeatureVersions(tx, vulnerability.ID, vulnerability.FixedIn)
	if err != nil {
		return err
	}

	return nil
}
