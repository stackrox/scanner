package pgsql

import (
	"bytes"
	"crypto/md5"
	"database/sql"
	"fmt"
	"github.com/stackrox/rox/pkg/set"

	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	"github.com/stackrox/rox/pkg/utils"
	"github.com/stackrox/scanner/database"
)

func (pgSQL *pgSQL) InsertRHELv2Vulnerabilities(vulnerabilities []*database.RHELv2Vulnerability) error {
	log.WithField("count", len(vulnerabilities)).Info("Inserting RHELv2 vulnerabilities")

	var i int
	var vulnerability *database.RHELv2Vulnerability
	for i, vulnerability = range vulnerabilities {
		if vulnerability.Package == nil || vulnerability.Package.Name == "" {
			continue
		}
		err := pgSQL.insertRHELv2Vulnerability(vulnerability)
		if err != nil {
			return err
		}
		if (i+1)%printEveryWhenInsertingVulns == 0 {
			log.Infof("Inserted %d/%d vulns", i+1, len(vulnerabilities))
		}
	}

	return nil
}

func (pgSQL *pgSQL) insertRHELv2Vulnerability(vuln *database.RHELv2Vulnerability) error {
	const (
		insertVuln = `
			INSERT INTO vuln (
				hash,
				name, issued, updated, links,
			    severity, cvss3, cvss2,
				package_name, package_module, package_arch,
				cpe,
				fixed_in_version, arch_operation
			) VALUES (
				$1,
				$2, $3, $4, $5,
				$6, $7, $8,
				$9, $10, $11,
				$12,
				$13, $14
			)
			ON CONFLICT (hash) DO NOTHING;`

		insertVulnDescription = `
			INSERT INTO vuln_description (
				hash, name, description
			) VALUES (
				$1, $2, $3
			)
			ON CONFLICT (hash) DO NOTHING;`
	)

	tx, err := pgSQL.Begin()
	if err != nil {
		return fmt.Errorf("unable to start transaction: %v", err)
	}

	descHash := md5.Sum(append([]byte(vuln.Name), []byte(vuln.Description)...))
	_, err = tx.Exec(insertVulnDescription, descHash[:], vuln.Name, vuln.Description)
	if err != nil {
		utils.IgnoreError(tx.Rollback)
		return errors.Wrapf(err, "inserting RHELv2 description for %s into the DB", vuln.Name)
	}

	pkg := vuln.Package
	for _, cpe := range vuln.CPEs {
		hash := md5Vuln(vuln, cpe)
		_, err = tx.Exec(insertVuln,
			hash,
			vuln.Name, vuln.Issued, vuln.Updated, vuln.Links,
			vuln.Severity, vuln.CVSSv3, vuln.CVSSv2,
			pkg.Name, pkg.Module, pkg.Arch,
			cpe,
			vuln.FixedInVersion, vuln.ArchOperation,
		)
		if err != nil {
			break
		}
	}

	if err != nil {
		utils.IgnoreError(tx.Rollback)
		return errors.Wrapf(err, "inserting RHELv2 vulnerability %s into the DB", vuln.Name)
	}

	if err := tx.Commit(); err != nil {
		utils.IgnoreError(tx.Rollback)
		return handleError("insertRHELv2Vulnerability.Commit()", err)
	}

	return nil
}

// md5Vuln creates an md5 hash from the members of the passed-in Vulnerability,
// giving us a stable, context-free identifier for this revision of the
// Vulnerability.
func md5Vuln(v *database.RHELv2Vulnerability, cpe string) []byte {
	var b bytes.Buffer
	b.WriteString(v.Name)
	// Ignore description, as it is stored separately.
	b.WriteString(v.Issued.String())
	b.WriteString(v.Updated.String())
	b.WriteString(v.Links)
	b.WriteString(v.Severity)
	b.WriteString(v.CVSSv3)
	b.WriteString(v.CVSSv2)
	// Use the given CPE.
	b.WriteString(cpe)
	if v.Package != nil {
		b.WriteString(v.Package.Name)
		b.WriteString(v.Package.Module)
		b.WriteString(v.Package.Arch)
	}
	b.WriteString(v.ArchOperation.String())
	b.WriteString(v.FixedInVersion)
	s := md5.Sum(b.Bytes())
	return s[:]
}

func (pgSQL *pgSQL) GetRHELv2Vulnerabilities(records []*database.RHELv2Record) (map[string][]*database.RHELv2Vulnerability, error) {
	vulnMap := make(map[string][]*database.RHELv2Vulnerability)

	// Ensures we only have one copy of each vulnerability per package.
	uniqueVulns := make(map[string]set.IntSet)

	tx, err := pgSQL.Begin()
	if err != nil {
		return nil, err
	}

	for _, record := range records {
		if record.Pkg != nil && record.Pkg.Name != "" {
			matchedVulns, err := pgSQL.getRHELv2Vulns(tx, record)
			if err != nil {
				utils.IgnoreError(tx.Rollback)
				return nil, err
			}

			recordID := record.Pkg.ID

			if _, ok := uniqueVulns[recordID]; !ok {
				uniqueVulns[recordID] = set.NewIntSet()
			}

			addedVulns := uniqueVulns[recordID]

			for _, matched := range matchedVulns {
				if !addedVulns.Contains(matched.ID) {
					addedVulns.Add(matched.ID)
					vulnMap[recordID] = append(vulnMap[recordID], matched)
				}
			}
		}
	}

	return vulnMap, nil
}

func (pgSQL *pgSQL) getRHELv2Vulns(tx *sql.Tx, record *database.RHELv2Record) ([]*database.RHELv2Vulnerability, error) {
	const (
		query = `
			SELECT
				vuln.id,
			    vuln.name,
				vuln_description.description,
				vuln.links,
				vuln.issued,
			    vuln.updated,
				vuln.severity,
				vuln.cvss3,
				vuln.cvss2,
				vuln.package_name,
				vuln.package_version,
				vuln.package_arch,
				vuln.arch_operation,
				vuln.fixed_in_version
			FROM
  				vuln
  				LEFT JOIN vuln_description ON
    				vuln.name = vuln_description.name
			WHERE
				vuln.package_name = $1
				AND vuln.package_module = $2
				AND vuln.cpe = $3;
		`
	)

	rows, err := tx.Query(query, record.Pkg.Name, record.Pkg.Module, record.CPE)

	if err != nil {
		return nil, err
	}
	defer utils.IgnoreError(rows.Close)

	var vulns []*database.RHELv2Vulnerability

	for rows.Next() {
		var vuln database.RHELv2Vulnerability
		var pkg database.Package
		err := rows.Scan(
			&vuln.ID,
			&vuln.Name,
			&vuln.Description,
			&vuln.Links,
			&vuln.Issued,
			&vuln.Updated,
			&vuln.Severity,
			&vuln.CVSSv3,
			&vuln.CVSSv2,
			&pkg.Name,
			&pkg.Version,
			&pkg.Arch,
			&vuln.ArchOperation,
			&vuln.FixedInVersion,
		)
		if err != nil {
			return nil, err
		}

		vuln.Package = &pkg
		vulns = append(vulns, &vuln)
	}

	return vulns, nil
}
