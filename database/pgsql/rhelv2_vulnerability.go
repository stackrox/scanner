///////////////////////////////////////////////////
// Influenced by ClairCore under Apache 2.0 License
// https://github.com/quay/claircore
///////////////////////////////////////////////////

package pgsql

import (
	"bytes"
	"context"
	"crypto/md5"
	"database/sql"
	"time"

	"github.com/lib/pq"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	"github.com/stackrox/rox/pkg/batcher"
	"github.com/stackrox/rox/pkg/set"
	"github.com/stackrox/rox/pkg/utils"
	"github.com/stackrox/scanner/database"
	"github.com/stackrox/scanner/database/metrics"
	"github.com/stackrox/scanner/pkg/rhelv2"
)

const (
	rhelv2InsertionBatchSize = 50
)

func (pgSQL *pgSQL) insertRHELv2Vulnerability(vulnStatement, vulnDescriptionStatement, vulnDeleteStatement *sql.Stmt, vuln *database.RHELv2Vulnerability) error {
	vulnDescriptionHash := md5VulnDescription(vuln.Description)
	for i, pkgInfo := range vuln.PackageInfos {
		for j, pkg := range pkgInfo.Packages {
			for k, cpe := range vuln.CPEs {
				vulnHash := md5Vuln(vuln, i, j, k)
				_, err := vulnStatement.Exec(
					vulnHash,
					vuln.Name, vuln.Title, vulnDescriptionHash,
					vuln.Issued, vuln.Updated,
					vuln.Link, vuln.Severity, vuln.CVSSv3, vuln.CVSSv2,
					pkg.Name, pkg.Module, pkg.Arch,
					cpe,
					pkgInfo.FixedInVersion, pkgInfo.ArchOperation,
				)
				if err != nil {
					return errors.Wrapf(err, "inserting RHELv2 vulnerability %q for package %q with cpe %q into the DB", vuln.Name, pkg.Name, cpe)
				}
			}
		}
	}

	_, err := vulnDescriptionStatement.Exec(vulnDescriptionHash, vuln.Description)
	if err != nil {
		return errors.Wrapf(err, "inserting RHELv2 vulnerability description for %q", vuln.Name)
	}

	if rhelv2.IsRedHatAdvisory(vuln.Name) {
		if len(vuln.SubCVEs) != 0 && len(vuln.PackageInfos) != 0 && len(vuln.CPEs) != 0 {
			packagesByModule := make(map[string][]string)
			for _, pkgInfo := range vuln.PackageInfos {
				for _, pkg := range pkgInfo.Packages {
					packagesByModule[pkg.Module] = append(packagesByModule[pkg.Module], pkg.Name)
				}
			}
			for module, packages := range packagesByModule {
				result, err := vulnDeleteStatement.Exec(pq.Array(vuln.SubCVEs), pq.Array(packages), pq.Array(vuln.CPEs), module)
				if err != nil {
					return errors.Wrapf(err, "deleting stale RHELv2 CVEs")
				}
				if log.IsLevelEnabled(log.DebugLevel) {
					affected, err := result.RowsAffected()
					if err != nil {
						return errors.Wrapf(err, "getting number of affected rows")
					}
					if affected != 0 {
						log.Debugf("removed %d vulnerability entries for %s", affected, vuln.Name)
					}
				}
			}
		}
	}

	return nil
}

func (pgSQL *pgSQL) insertRHELv2VulnerabilitiesBatched(vulnStmt, vulnDescriptionStmt, vulnDeleteStmt *sql.Stmt, vulnerabilities []*database.RHELv2Vulnerability) error {
	tx, err := pgSQL.Begin()
	if err != nil {
		return errors.Wrap(err, "unable to start transaction")
	}

	vulnStmt = tx.Stmt(vulnStmt)
	defer utils.IgnoreError(vulnStmt.Close)

	vulnDescriptionStmt = tx.Stmt(vulnDescriptionStmt)
	defer utils.IgnoreError(vulnDescriptionStmt.Close)

	vulnDeleteStmt = tx.Stmt(vulnDeleteStmt)
	defer utils.IgnoreError(vulnDeleteStmt.Close)

	for _, vulnerability := range vulnerabilities {
		if len(vulnerability.PackageInfos) == 0 {
			continue
		}

		err = pgSQL.insertRHELv2Vulnerability(vulnStmt, vulnDescriptionStmt, vulnDeleteStmt, vulnerability)
		if err != nil {
			utils.IgnoreError(tx.Rollback)
			return err
		}
	}
	if err := tx.Commit(); err != nil {
		return handleError("insertRHELv2Vulnerability.Commit()", err)
	}

	return nil
}

func (pgSQL *pgSQL) InsertRHELv2Vulnerabilities(vulnerabilities []*database.RHELv2Vulnerability) error {
	log.WithField("count", len(vulnerabilities)).Debug("Inserting RHELv2 vulnerabilities")
	defer metrics.ObserveQueryTime("insertRHELv2Vulnerabilities", "all", time.Now())

	vulnStmt, err := pgSQL.Prepare(insertRHELv2Vuln)
	if err != nil {
		return err
	}
	defer utils.IgnoreError(vulnStmt.Close)
	vulnDescriptionStmt, err := pgSQL.Prepare(insertRHELv2VulnDescription)
	if err != nil {
		return err
	}
	defer utils.IgnoreError(vulnDescriptionStmt.Close)
	vulnDeleteStmt, err := pgSQL.Prepare(deleteStaleRHELv2Vulns)
	if err != nil {
		return err
	}
	defer utils.IgnoreError(vulnDeleteStmt.Close)

	batch := batcher.New(len(vulnerabilities), rhelv2InsertionBatchSize)
	for start, end, ok := batch.Next(); ok; start, end, ok = batch.Next() {
		startTime := time.Now()
		if err := pgSQL.insertRHELv2VulnerabilitiesBatched(vulnStmt, vulnDescriptionStmt, vulnDeleteStmt, vulnerabilities[start:end]); err != nil {
			return err
		}
		metrics.ObserveQueryTime("insertRHELv2Vulnerabilities", "batchInsert", startTime)
		if end%printEveryWhenInsertingVulns == 0 {
			log.Infof("Inserted %d/%d vulns", end, len(vulnerabilities))
		}
	}
	return nil
}

// md5Vuln creates an md5 hash from the members of the passed-in Vulnerability,
// giving us a stable, context-free identifier for this revision of the
// Vulnerability.
func md5Vuln(v *database.RHELv2Vulnerability, pkgInfoIdx, pkgIdx, cpeIdx int) []byte {
	// Declare variables before necessary for readability.
	pkgInfo := v.PackageInfos[pkgInfoIdx]
	pkg := pkgInfo.Packages[pkgIdx]
	cpe := v.CPEs[cpeIdx]

	var b bytes.Buffer
	b.WriteString(v.Name)
	b.WriteString(v.Title)
	// Ignore description, as it is stored separately.
	b.WriteString(v.Issued.String())
	b.WriteString(v.Updated.String())
	b.WriteString(v.Link)
	b.WriteString(v.Severity)
	b.WriteString(v.CVSSv3)
	b.WriteString(v.CVSSv2)
	b.WriteString(pkg.Name)
	b.WriteString(pkg.Module)
	b.WriteString(pkg.Arch)
	b.WriteString(cpe)
	b.WriteString(pkgInfo.FixedInVersion)
	b.WriteString(pkgInfo.ArchOperation.String())

	checksum := md5.Sum(b.Bytes())
	return checksum[:]
}

// md5VulnDescription creates an md5 hash from given vulnerability description,
// giving us a stable, context-free identifier for this revision of the
// description.
func md5VulnDescription(description string) []byte {
	checksum := md5.Sum([]byte(description))
	return checksum[:]
}

func (pgSQL *pgSQL) GetRHELv2Vulnerabilities(records []*database.RHELv2Record) (map[int][]*database.RHELv2Vulnerability, error) {
	vulnMap := make(map[int][]*database.RHELv2Vulnerability)

	// Ensures we only have one copy of each vulnerability per package.
	uniqueVulns := make(map[int]set.StringSet)

	defer metrics.ObserveQueryTime("getRHELv2Vulnerabilities", "all", time.Now())

	tx, err := pgSQL.BeginTx(context.Background(), &sql.TxOptions{
		ReadOnly: true,
	})
	if err != nil {
		return nil, errors.Wrap(err, "unable to start transaction")
	}

	for _, record := range records {
		if record.Pkg != nil && record.Pkg.Name != "" {
			matchedVulns, err := pgSQL.getRHELv2Vulns(tx, record)
			if err != nil {
				utils.IgnoreError(tx.Rollback)
				return nil, errors.Wrapf(err, "getting RHELv2 vulns")
			}

			recordID := record.Pkg.ID

			if _, ok := uniqueVulns[recordID]; !ok {
				uniqueVulns[recordID] = set.NewStringSet()
			}

			addedVulns := uniqueVulns[recordID]

			for _, matched := range matchedVulns {
				if addedVulns.Add(matched.Name) {
					vulnMap[recordID] = append(vulnMap[recordID], matched)
				}
			}
		}
	}

	if err := tx.Commit(); err != nil {
		utils.IgnoreError(tx.Rollback)
		return nil, handleError("GetRHELv2Vulnerabilities.Commit()", err)
	}

	return vulnMap, nil
}

func (pgSQL *pgSQL) getRHELv2Vulns(tx *sql.Tx, record *database.RHELv2Record) ([]*database.RHELv2Vulnerability, error) {
	rows, err := tx.Query(searchRHELv2Vulns, record.Pkg.Name, record.Pkg.Module, record.CPE)

	if err != nil {
		return nil, errors.Wrapf(err, "Searching for package: %s, module: %s, cpe: %s", record.Pkg.Name, record.Pkg.Module, record.CPE)
	}
	defer utils.IgnoreError(rows.Close)

	var vulns []*database.RHELv2Vulnerability

	for rows.Next() {
		var pkg database.RHELv2Package
		pkgInfo := database.RHELv2PackageInfo{
			Packages: []*database.RHELv2Package{&pkg},
		}
		vuln := database.RHELv2Vulnerability{
			PackageInfos: []*database.RHELv2PackageInfo{&pkgInfo},
		}
		err := rows.Scan(
			&vuln.ID,
			&vuln.Name,
			&vuln.Title,
			&vuln.Description,
			&vuln.Link,
			&vuln.Issued,
			&vuln.Updated,
			&vuln.Severity,
			&vuln.CVSSv3,
			&vuln.CVSSv2,
			&pkg.Name,
			&pkg.Arch,
			&pkgInfo.FixedInVersion,
			&pkgInfo.ArchOperation,
		)
		if err != nil {
			return nil, errors.Wrapf(err, "Scanning row for package: %s, module: %s, cpe: %s", record.Pkg.Name, record.Pkg.Module, record.CPE)
		}

		vulns = append(vulns, &vuln)
	}
	if err := rows.Err(); err != nil {
		return nil, errors.Wrapf(err, "Scanning rows for package: %s, module: %s, cpe: %s", record.Pkg.Name, record.Pkg.Module, record.CPE)
	}

	return vulns, nil
}
