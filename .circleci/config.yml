version: 2.1

defaultImage: &defaultImage
  image: docker.io/stackrox/apollo-ci:0.2.8
  auth:
    username: $DOCKER_IO_PULL_USERNAME
    password: $DOCKER_IO_PULL_PASSWORD

defaultWorkingDirectory: &defaultWorkingDirectory '/go/src/github.com/stackrox/scanner'

defaults: &defaults
  docker:
    - *defaultImage
  working_directory: /go/src/github.com/stackrox/scanner

runOnAllTags: &runOnAllTags
  filters:
    tags:
      only: /.*/

runOnAllTagsWithDockerIOPullCtx: &runOnAllTagsWithDockerIOPullCtx
  <<: *runOnAllTags
  context: docker-io-pull

commands:
  check-label-to-run:
    description: Run on master or tags, but skip on PRs unless the given label is provided
    parameters:
      label:
        type: string
    steps:
      - run:
          name: Determine whether to run step
          command: |
            set +e
            if [[ "${CIRCLE_BRANCH}" == "master" || -n "${CIRCLE_TAG}" ]]; then
              echo "On master or tag, running the step"
            else
              .circleci/pr_has_label.sh "<< parameters.label >>"
              if [[ $? -eq 1 ]]; then
                echo "Skipping tests because we're on a PR. Apply the << parameters.label >> label to your PR if you want to run them."
                circleci step halt
              fi
            fi

  setup-gcp:
    description: Set up GCP service account and configure gcloud
    parameters:
      service-account-env:
        type: string
        default: GOOGLE_SA_CIRCLECI_SCANNER
    steps:
      - run:
          name: Configure GCP service account and gcloud
          command: |
            cci-export GOOGLE_APPLICATION_CREDENTIALS /tmp/gcp.json
            echo "${<< parameters.service-account-env >>}" > "${GOOGLE_APPLICATION_CREDENTIALS}"
            chmod 0600 "${GOOGLE_APPLICATION_CREDENTIALS}"
            gcloud auth activate-service-account --key-file "${GOOGLE_APPLICATION_CREDENTIALS}"
            gcloud auth list
            gcloud auth configure-docker
            gcloud config set project stackrox-ci
            gcloud config set core/disable_prompts True

  create-gke:
    parameters:
      wait:
        type: boolean
        default: true

    steps:
      - run:
          name: Create GKE cluster
          command: |
            source .circleci/create-cluster.sh && create-cluster
            <<# parameters.wait >>
            wait-for-cluster
            <</ parameters.wait >>

  teardown-gke:
    steps:
      - run:
          name: Tear down GKE cluster
          command: |
            [[ -n "$CLUSTER_NAME" ]]
            gcloud container clusters delete "$CLUSTER_NAME" --async

          when: always

  provision-gke-cluster:
    parameters:
      cluster-id:
        type: string
      num-nodes:
        type: integer
        default: 1

    steps:
      - setup-gcp
      - run:
          name: Assign environment variables
          command: |
            CLUSTER_NAME="stackrox-scanner-ci-<< parameters.cluster-id >>-${CIRCLE_BUILD_NUM}"
            cci-export CLUSTER_NAME "$CLUSTER_NAME"
            echo "Assigned cluster name is $CLUSTER_NAME"

            NUM_NODES="<< parameters.num-nodes >>"
            cci-export NUM_NODES "$NUM_NODES"
            echo "Number of nodes for cluster is $NUM_NODES"

      - create-gke:
          wait: false

      - run:
          name: Save cluster config
          command: |
            CONFIG_DIR="/tmp/.ci-clusters/<< parameters.cluster-id >>"
            mkdir -p "$CONFIG_DIR"
            echo "$CLUSTER_NAME" >>"${CONFIG_DIR}/name"
            gcloud config get-value compute/zone >>"${CONFIG_DIR}/zone"

      - run:
          name: Tear down cluster upon failure
          command: |
            gcloud container clusters delete "$CLUSTER_NAME" --async
          when: on_fail

      - persist_to_workspace:
          root: /tmp
          paths:
            - .ci-clusters/<< parameters.cluster-id >>

  attach-gke-cluster:
    parameters:
      cluster-id:
        type: string

    steps:
      - run:
          name: Restore config for << parameters.cluster-id >> cluster
          command: |
            CONFIG_DIR="/tmp/.ci-clusters/<< parameters.cluster-id >>"
            CLUSTER_NAME="$(cat "${CONFIG_DIR}/name")"
            [[ -n "$CLUSTER_NAME" ]]
            ZONE="$(cat "${CONFIG_DIR}/zone")"
            [[ -n "$ZONE" ]]
            gcloud config set compute/zone "$ZONE"
            cmd=(gcloud container clusters get-credentials --project stackrox-ci --zone "$ZONE" "$CLUSTER_NAME")
            "${cmd[@]}"
            echo "Restored config for cluster ${CLUSTER_NAME}"
            cci-export CLUSTER_NAME "$CLUSTER_NAME"
            echo
            echo "Run the following command to attach to the cluster:"
            echo
            printf " %q" "${cmd[@]}"
            echo

  build-and-push-image:
    parameters:
      make-image-target:
        type: string
      image-name-suffix:
        type: string
        default: ""

    steps:
      - checkout
      - setup_remote_docker
      - setup-gcp

      - run:
          name: Pull definitions dumps
          command: |
            gsutil cp gs://stackrox-scanner-ci-vuln-dump/pg-definitions.sql.gz image/dump/definitions.sql.gz
            gsutil cp gs://stackrox-scanner-ci-vuln-dump/nvd-definitions.zip /tmp/nvd-definitions.zip
            unzip -d image/dump /tmp/nvd-definitions.zip
            rm /tmp/nvd-definitions.zip

      - run:
          name: Build images
          command: make << parameters.make-image-target >>

      - run:
          name: Ensure image is not dirty
          command: git diff --exit-code HEAD

      - run:
          name: Push images
          command: |
            tag="$(./get-tag)"
            scanner_image_name="scanner<< parameters.image-name-suffix >>"
            db_image_name="scanner-db<< parameters.image-name-suffix >>"

            gcr_scanner_image="us.gcr.io/stackrox-ci/${scanner_image_name}:${tag}"
            gcr_db_image="us.gcr.io/stackrox-ci/${db_image_name}:${tag}"

            dockerhub_scanner_image="stackrox/${scanner_image_name}:${tag}"
            dockerhub_db_image="stackrox/${db_image_name}:${tag}"

            docker push "${gcr_scanner_image}"
            docker push "${gcr_db_image}"

            docker login -u "$DOCKER_IO_PUSH_USERNAME" -p "$DOCKER_IO_PUSH_PASSWORD" docker.io

            docker tag "${gcr_scanner_image}" "${dockerhub_scanner_image}"
            docker push "${dockerhub_scanner_image}"

            docker tag "${gcr_db_image}" "${dockerhub_db_image}"
            docker push "${dockerhub_db_image}"

  run-e2e-tests:
    parameters:
      cluster-id:
        type: string

    steps:
      - checkout
      - setup_remote_docker
      - setup-gcp

      - attach_workspace:
          at: /tmp

      - attach-gke-cluster:
          cluster-id: << parameters.cluster-id >>

      - run:
          name: Deploy into the cluster
          command: |
            if [[ "<< parameters.cluster-id >>" == "rhel" ]]; then
              make deploy-rhel
            else
              make deploy
            fi

      - run:
          name: Wait for the pod to be running, and port-forward
          command: |
            sleep 5
            kubectl -n stackrox get pod
            POD="$(kubectl -n stackrox get pod -o jsonpath='{.items[?(@.metadata.labels.app=="scanner")].metadata.name}')"
            [[ -n "${POD}" ]]
            kubectl -n stackrox wait --for=condition=ready "pod/${POD}" --timeout=3m
            kubectl -n stackrox get pod

            success=0
            for i in $(seq 1 10); do
              nohup kubectl port-forward -n stackrox "${POD}" "8080:8080" & # Legacy clairify endpoint
              nohup kubectl port-forward -n stackrox "${POD}" "8443:8443" & # gRPC endpoint
              curl --retry 12 --retry-connrefused -4 --retry-delay 5 --retry-max-time 60 -skf 'https://localhost:8080/clairify/ping' || touch FAIL
              curl --retry 12 --retry-connrefused -4 --retry-delay 5 --retry-max-time 60 -skf 'https://localhost:8443/v1/ping' || touch FAIL
              if [[ ! -f FAIL ]]; then
                success=1
                break
              fi
              echo "Port-forwarding failed."
              cat nohup.out || true
              rm nohup.out || true
              rm FAIL || true
              pkill kubectl || true
              sleep 5
            done

            [[ "${success}" -gt 0 ]]

      - run:
          name: Run sanity tests
          command: |
            export SCANNER_ENDPOINT=https://localhost:8080
            make e2e-tests

      - run:
          name: Collect k8s logs
          command: |
            .circleci/collect-service-logs.sh stackrox
            .circleci/collect-service-logs.sh kube-system
          when: always

      - store_artifacts:
          path: /tmp/k8s-service-logs
          destination: k8s-service-logs-<< parameters.cluster-id >>

      - run:
          name: Verify the scanner did not restart
          command: |
            if [[ "$(ls /tmp/k8s-service-logs/stackrox/*-previous.log | wc -l)" != 0 ]]; then
                ls /tmp/k8s-service-logs/stackrox/*-previous.log
                exit 1
            fi
            cat nohup.out || true
          when: always

      - teardown-gke

jobs:
  unit-tests:
    <<: *defaults
    steps:
      - checkout

      - run:
          name: Install dependencies
          command: make deps

      - run:
          name: Run unit tests
          command: make unit-tests

  style-checks:
    <<: *defaults
    steps:
      - checkout

      - run:
          name: Install dependencies
          command: make deps

      - run:
          name: Run style checks
          command: make style

      - run:
          name: Run style checks on test code
          command: make -C qa-tests style

  generate-genesis-dump:
    <<: *defaults
    steps:
      - checkout
      - check-label-to-run:
          label: ci-fetch-dumps
      - run:
          name: Build updater, and persist to workspace
          command: |
            make build-updater
            mkdir -p /tmp/updater-bin
            cp ./bin/updater /tmp/updater-bin/

      - run:
          name: Generate the genesis dump
          command: |
            mkdir -p /tmp/genesis-dump
            ./bin/updater generate-dump --out-file /tmp/genesis-dump/dump.zip
            ls -lrt /tmp/genesis-dump

      - persist_to_workspace:
          root: /tmp
          paths:
            - genesis-dump
            - updater-bin

  create-postgres-dump-from-genesis-dump:
    docker:
      - *defaultImage
      - image: postgres:12.0-alpine
    working_directory: *defaultWorkingDirectory
    steps:
      - checkout
      - check-label-to-run:
          label: ci-fetch-dumps
      - setup_remote_docker
      - setup-gcp

      - attach_workspace:
          at: /tmp

      - run:
          name: Restore updater bin
          command: |
            cp /tmp/updater-bin/updater ./bin/

      - run:
          name: Load vuln contents into postgres
          command: |
            ./bin/updater load-dump --postgres-host 127.0.0.1 --postgres-port 5432 --dump-file /tmp/genesis-dump/dump.zip

      - run:
          name: Take a PG dump
          command: |
            pg_dump -U postgres postgres://127.0.0.1:5432 > pg-definitions.sql
            gzip --best pg-definitions.sql

      - run:
          name: Upload PG dump to Google Storage
          command: |
            gsutil cp pg-definitions.sql.gz gs://stackrox-scanner-ci-vuln-dump

  upload-nvd-dump-for-embedding-into-image:
    <<: *defaults
    steps:
      - checkout
      - check-label-to-run:
          label: ci-fetch-dumps
      - setup-gcp
      - attach_workspace:
          at: /tmp

      - run:
          name: Generate NVD dump
          command: |
            zip /tmp/genesis-dump/dump.zip 'nvd/*' --copy --out nvd-definitions.zip

      - run:
          name: Upload to Google Storage
          command: |
            gsutil cp nvd-definitions.zip gs://stackrox-scanner-ci-vuln-dump

  create-diff-dumps:
    <<: *defaults
    steps:
      - checkout
      - check-label-to-run:
          label: ci-fetch-dumps
      - setup-gcp
      - attach_workspace:
          at: /tmp

      - run:
          name: Restore updater bin
          command: |
            cp /tmp/updater-bin/updater ./bin/

      - run:
          name: Create diff for each manifest
          command: |
            mkdir -p /tmp/diff-dumps
            while IFS=$'\t' read -r dumploc timestamp; do
              dump_file_name="${dumploc##*/}"
              dump_file_name_no_ext="${dump_file_name%.*}"
              echo "Pulling genesis dump from ${dumploc}"
              gsutil cp "${dumploc}" .
              timestamp_in_zip="$(unzip -p "${dump_file_name}" manifest.json | jq -r '.until')"
              echo "Got timestamps -- from zip: ${timestamp_in_zip}; from manifest: ${timestamp}"
              [[ "${timestamp_in_zip}" == "${timestamp}" ]] # Assertion on the manifest contents
              ./bin/updater diff-dumps --base-dump "${dump_file_name}" --head-dump /tmp/genesis-dump/dump.zip --out-file "/tmp/diff-dumps/${dump_file_name_no_ext}/diff.zip"
            done < <(jq -r '.knownGenesisDumps | .[]| [.dumpLocationInGS, .timestamp] | @tsv' < image/dump/genesis_manifests.json)

      - persist_to_workspace:
          root: /tmp
          paths:
            - diff-dumps

  upload-diff-dumps-and-offline-dumps:
    <<: *defaults
    steps:
      - checkout
      - check-label-to-run:
          label: ci-fetch-dumps

      - setup-gcp:
          service-account-env: GOOGLE_SA_STACKROX_HUB_VULN_DUMP_UPLOADER

      - attach_workspace:
          at: /tmp

      - run:
          name: Upload each diff dump to the prod bucket
          command: |
            mkdir -p /tmp/diff-dumps
            while IFS=$'\t' read -r dumploc diffloc; do
              dump_file_name="${dumploc##*/}"
              dump_file_name_no_ext="${dump_file_name%.*}"
              expected_zip_file_loc="/tmp/diff-dumps/${dump_file_name_no_ext}/diff.zip"
              [[ -f "${expected_zip_file_loc}" ]]
              [[ -n "${diffloc}" ]]
              gsutil cp "${expected_zip_file_loc}" "${diffloc}"
            done < <(jq -r '.knownGenesisDumps | .[]| [.dumpLocationInGS, .diffLocation] | @tsv' < image/dump/genesis_manifests.json)

      - run:
          name: Generate offline dump
          command: |
            mkdir -p /tmp/offline-dump

            # Fetch the scanner dump which is marked as the base for offline dumps.
            # For offline dumps, we just use one base (the oldest base which is in a version of scanner still supported)
            # for simplicity.
            offline_dumps="$(jq '.knownGenesisDumps | [.[] | select(.baseForOfflineDumps == true)]' < image/dump/genesis_manifests.json)"
            echo "Got offline dumps list: ${offline_dumps}"
            [[ "$(echo "${offline_dumps}" | jq 'length')" -eq 1 ]]
            offline_diff_location="$(echo "${offline_dumps}" | jq -r '.[0] | .diffLocation')"
            gsutil cp -r "${offline_diff_location}" /tmp/offline-dump/scanner-defs.zip

            # Prepare k8s and istio dump
            mkdir -p /tmp/scratch
            gsutil cp -r gs://definitions.stackrox.io/cve/* /tmp/scratch/
            cd /tmp/scratch
            zip -r /tmp/offline-dump/k8s-istio.zip *

            cd /tmp/offline-dump
            zip scanner-vuln-updates.zip scanner-defs.zip k8s-istio.zip
            gsutil cp scanner-vuln-updates.zip gs://sr-roxc/scanner/scanner-vuln-updates.zip

  build:
    <<: *defaults
    steps:
      - build-and-push-image:
          make-image-target: image

  build-rhel:
    <<: *defaults
    steps:
      - build-and-push-image:
          make-image-target: image-rhel
          image-name-suffix: "-rhel"

  provision-cluster:
    <<: *defaults
    steps:
      - checkout
      - setup_remote_docker
      - provision-gke-cluster:
          cluster-id: alpine

  e2e-tests:
    <<: *defaults
    steps:
      - run-e2e-tests:
          cluster-id: alpine

  e2e-tests-rhel:
    <<: *defaults
    steps:
      - run-e2e-tests:
          cluster-id: rhel

  provision-cluster-rhel:
    <<: *defaults
    steps:
      - checkout
      - setup_remote_docker
      - provision-gke-cluster:
          cluster-id: rhel

workflows:
  version: 2

  build:
    jobs:
    - generate-genesis-dump:
        <<: *runOnAllTagsWithDockerIOPullCtx
    - create-postgres-dump-from-genesis-dump:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
          - generate-genesis-dump
    - create-diff-dumps:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
          - generate-genesis-dump
    - upload-nvd-dump-for-embedding-into-image:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
          - generate-genesis-dump
    - upload-diff-dumps-and-offline-dumps:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
          - create-diff-dumps
    - unit-tests:
        <<: *runOnAllTagsWithDockerIOPullCtx
    - style-checks:
        <<: *runOnAllTagsWithDockerIOPullCtx
    - build:
        <<: *runOnAllTags
        context: docker-io-and-stackrox-io-push
        requires:
          - create-postgres-dump-from-genesis-dump
          - upload-nvd-dump-for-embedding-into-image
    - build-rhel:
        <<: *runOnAllTags
        context: docker-io-and-stackrox-io-push
        requires:
          - create-postgres-dump-from-genesis-dump
          - upload-nvd-dump-for-embedding-into-image
    - provision-cluster:
        <<: *runOnAllTagsWithDockerIOPullCtx
    - provision-cluster-rhel:
        <<: *runOnAllTagsWithDockerIOPullCtx
    - e2e-tests:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
          - build
          - provision-cluster
    - e2e-tests-rhel:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
          - build-rhel
          - provision-cluster-rhel
