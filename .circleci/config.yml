version: 2.1

defaultImage: &defaultImage
  image: docker.io/stackrox/apollo-ci:0.3.5
  auth:
    username: $DOCKER_IO_PULL_USERNAME
    password: $DOCKER_IO_PULL_PASSWORD

defaultWorkingDirectory: &defaultWorkingDirectory '/go/src/github.com/stackrox/scanner'

defaults: &defaults
  docker:
    - *defaultImage
  working_directory: /go/src/github.com/stackrox/scanner

runOnAllTags: &runOnAllTags
  filters:
    tags:
      only: /.*/

runOnAllTagsWithDockerIOPullCtx: &runOnAllTagsWithDockerIOPullCtx
  <<: *runOnAllTags
  context: docker-io-pull

commands:
  check-on-master-or-tag:
    description: Run on master or tags only
    steps:
      - run:
          name: Determine whether to run step
          command: |
            if [[ "${CIRCLE_BRANCH}" == "master" || -n "${CIRCLE_TAG}" ]]; then
              echo "On master or tag, running the step"
            else
              echo "Not on master or tag, halting step"
              circleci step halt
            fi

  check-label-to-run:
    description: Run on master or tags, but skip on PRs unless the given label is provided
    parameters:
      label:
        type: string
    steps:
      - run:
          name: Determine whether to run step
          command: |
            set +e
            if [[ "${CIRCLE_BRANCH}" == "master" || -n "${CIRCLE_TAG}" ]]; then
              echo "On master or tag, running the step"
            else
              .circleci/pr_has_label.sh "<< parameters.label >>"
              if [[ $? -eq 1 ]]; then
                echo "Skipping tests because we're on a PR. Apply the << parameters.label >> label to your PR if you want to run them."
                circleci step halt
              fi
            fi

  wait-for-scanner-and-pf:
    description: Wait for the scanner pod to meet the given condition, and port-forward
    parameters:
      condition:
        type: string
      sleep-after-condition-met:
        type: integer
        default: 0
    steps:
      - run:
          name: Wait for the pod to be << parameters.condition >>, and port-forward
          command: |
            sleep 5
            kubectl -n stackrox get pod
            POD="$(kubectl -n stackrox get pod -o jsonpath='{.items[?(@.metadata.labels.app=="scanner")].metadata.name}')"
            [[ -n "${POD}" ]]
            kubectl -n stackrox wait "--for=condition=<< parameters.condition >>" "pod/${POD}" --timeout=3m
            sleep << parameters.sleep-after-condition-met >>
            kubectl -n stackrox get pod

            success=0
            for i in $(seq 1 10); do
              nohup kubectl port-forward -n stackrox "${POD}" "8080:8080" & # Legacy clairify endpoint
              nohup kubectl port-forward -n stackrox "${POD}" "8443:8443" & # gRPC endpoint
              curl --retry 12 --retry-connrefused -4 --retry-delay 5 --retry-max-time 60 -sk 'https://localhost:8080/clairify/ping' || touch FAIL
              curl --retry 12 --retry-connrefused -4 --retry-delay 5 --retry-max-time 60 -skf 'https://localhost:8443/v1/ping' || touch FAIL
              if [[ ! -f FAIL ]]; then
                success=1
                break
              fi
              echo "Port-forwarding failed."
              cat nohup.out || true
              rm nohup.out || true
              rm FAIL || true
              pkill kubectl || true
              sleep 5
            done

            [[ "${success}" -gt 0 ]]

  scanner-db-pf:
    description: Port-forward the scanner db
    steps:
      - run:
          name: Port-forward
          command: |
            sleep 5
            kubectl -n stackrox get pod
            POD="$(kubectl -n stackrox get pod -o jsonpath='{.items[?(@.metadata.labels.app=="scanner-db")].metadata.name}')"
            [[ -n "${POD}" ]]
            kubectl -n stackrox wait "--for=condition=Ready" "pod/${POD}" --timeout=10m
            nohup kubectl port-forward -n stackrox "${POD}" "5432:5432" & # PostgreSQL endpoint.
            sleep 10

  setup-gcp:
    description: Set up GCP service account and configure gcloud
    parameters:
      service-account-env:
        type: string
        default: GOOGLE_SA_CIRCLECI_SCANNER
    steps:
      - run:
          name: Configure GCP service account and gcloud
          command: |
            cci-export GOOGLE_APPLICATION_CREDENTIALS /tmp/gcp.json
            echo "${<< parameters.service-account-env >>}" > "${GOOGLE_APPLICATION_CREDENTIALS}"
            chmod 0600 "${GOOGLE_APPLICATION_CREDENTIALS}"
            gcloud auth activate-service-account --key-file "${GOOGLE_APPLICATION_CREDENTIALS}"
            gcloud auth list
            gcloud auth configure-docker
            gcloud config set project stackrox-ci
            gcloud config set core/disable_prompts True

  create-gke:
    parameters:
      wait:
        type: boolean
        default: true

    steps:
      - run:
          name: Create GKE cluster
          command: |
            source .circleci/create-cluster.sh && create-cluster
            <<# parameters.wait >>
            wait-for-cluster
            <</ parameters.wait >>

  teardown-gke:
    steps:
      - run:
          name: Tear down GKE cluster
          command: |
            [[ -n "$CLUSTER_NAME" ]]
            gcloud container clusters delete "$CLUSTER_NAME" --async

          when: always

  provision-gke-cluster:
    parameters:
      cluster-id:
        type: string
      num-nodes:
        type: integer
        default: 1

    steps:
      - setup-gcp
      - run:
          name: Assign environment variables
          command: |
            CLUSTER_NAME="stackrox-scanner-ci-<< parameters.cluster-id >>-${CIRCLE_BUILD_NUM}"
            cci-export CLUSTER_NAME "$CLUSTER_NAME"
            echo "Assigned cluster name is $CLUSTER_NAME"

            NUM_NODES="<< parameters.num-nodes >>"
            cci-export NUM_NODES "$NUM_NODES"
            echo "Number of nodes for cluster is $NUM_NODES"

      - create-gke:
          wait: false

      - run:
          name: Save cluster config
          command: |
            CONFIG_DIR="/tmp/.ci-clusters/<< parameters.cluster-id >>"
            mkdir -p "$CONFIG_DIR"
            echo "$CLUSTER_NAME" >>"${CONFIG_DIR}/name"
            gcloud config get-value compute/zone >>"${CONFIG_DIR}/zone"

      - run:
          name: Tear down cluster upon failure
          command: |
            gcloud container clusters delete "$CLUSTER_NAME" --async
          when: on_fail

      - persist_to_workspace:
          root: /tmp
          paths:
            - .ci-clusters/<< parameters.cluster-id >>

  attach-gke-cluster:
    parameters:
      cluster-id:
        type: string

    steps:
      - run:
          name: Restore config for << parameters.cluster-id >> cluster
          command: |
            CONFIG_DIR="/tmp/.ci-clusters/<< parameters.cluster-id >>"
            CLUSTER_NAME="$(cat "${CONFIG_DIR}/name")"
            [[ -n "$CLUSTER_NAME" ]]
            ZONE="$(cat "${CONFIG_DIR}/zone")"
            [[ -n "$ZONE" ]]
            gcloud config set compute/zone "$ZONE"
            cmd=(gcloud container clusters get-credentials --project stackrox-ci --zone "$ZONE" "$CLUSTER_NAME")
            "${cmd[@]}"
            echo "Restored config for cluster ${CLUSTER_NAME}"
            cci-export CLUSTER_NAME "$CLUSTER_NAME"
            echo
            echo "Run the following command to attach to the cluster:"
            echo
            printf " %q" "${cmd[@]}"
            echo

  build-and-push-image:
    parameters:
      make-image-target:
        type: string
      image-name-suffix:
        type: string
        default: ""

    steps:
      - checkout
      - setup_remote_docker
      - setup-gcp
      - attach_workspace:
          at: /tmp

      - run:
          name: Pull definitions dumps
          command: |
            if .circleci/pr_has_label.sh "generate-dumps-on-pr"; [[ $? -eq 1 ]]; then
              echo "Label generate-dumps-on-pr not set. Pulling dumps from GCS bucket"
              gsutil cp gs://stackrox-scanner-ci-vuln-dump/pg-definitions.sql.gz image/db/dump/definitions.sql.gz
              gsutil cp gs://stackrox-scanner-ci-vuln-dump/nvd-definitions.zip /tmp/nvd-definitions.zip
              gsutil cp gs://stackrox-scanner-ci-vuln-dump/k8s-definitions.zip /tmp/k8s-definitions.zip
            else
              cp /tmp/postgres/pg-definitions.sql.gz image/db/dump/definitions.sql.gz
              zip /tmp/genesis-dump/dump.zip 'nvd/*' --copy --out /tmp/nvd-definitions.zip
              zip /tmp/genesis-dump/dump.zip 'k8s/*' --copy --out /tmp/k8s-definitions.zip
            fi

            unzip -d image/scanner/dump /tmp/nvd-definitions.zip
            unzip -d image/scanner/dump /tmp/k8s-definitions.zip

      - run:
          name: Build images
          command: make << parameters.make-image-target >>

      - run:
          name: Ensure image is not dirty
          command: git diff --exit-code HEAD

      - run:
          name: Push images
          command: |
            tag="$(./get-tag)"
            scanner_image_name="scanner<< parameters.image-name-suffix >>"
            db_image_name="scanner-db<< parameters.image-name-suffix >>"

            gcr_scanner_image="us.gcr.io/stackrox-ci/${scanner_image_name}:${tag}"
            gcr_db_image="us.gcr.io/stackrox-ci/${db_image_name}:${tag}"

            dockerhub_scanner_image="stackrox/${scanner_image_name}:${tag}"
            dockerhub_db_image="stackrox/${db_image_name}:${tag}"

            docker push "${gcr_scanner_image}"
            docker push "${gcr_db_image}"

            docker login -u "$DOCKER_IO_PUSH_USERNAME" -p "$DOCKER_IO_PUSH_PASSWORD" docker.io

            docker tag "${gcr_scanner_image}" "${dockerhub_scanner_image}"
            docker push "${dockerhub_scanner_image}"

            docker tag "${gcr_db_image}" "${dockerhub_db_image}"
            docker push "${dockerhub_db_image}"

            if [[ -n "$CIRCLE_TAG" ]]; then
                docker login -u "$STACKROX_IO_PUSH_USERNAME" -p "$STACKROX_IO_PUSH_PASSWORD" stackrox.io

                stackrox_io_scanner_image="stackrox.io/${scanner_image_name}:${tag}"
                stackrox_io_scanner_db_image="stackrox.io/${db_image_name}:${tag}"

                docker tag "${gcr_scanner_image}" "${stackrox_io_scanner_image}"
                docker tag "${gcr_db_image}" "${stackrox_io_scanner_db_image}"

                docker push "${stackrox_io_scanner_image}"
                docker push "${stackrox_io_scanner_db_image}"
            fi
  run-e2e-tests:
    parameters:
      cluster-id:
        type: string

    steps:
      - checkout
      - setup_remote_docker
      - setup-gcp

      - attach_workspace:
          at: /tmp

      - attach-gke-cluster:
          cluster-id: << parameters.cluster-id >>

      - run:
          name: Deploy into the cluster
          command: |
            if [[ "<< parameters.cluster-id >>" == "rhel" ]]; then
              make deploy-rhel
            else
              make deploy
            fi

      - wait-for-scanner-and-pf:
          condition: Ready

      - run:
          name: Run sanity tests
          command: |
            make e2e-tests

      - run:
          name: Collect k8s logs
          command: |
            .circleci/collect-service-logs.sh stackrox
            .circleci/collect-service-logs.sh kube-system
          when: always

      - run:
          name: Verify the scanner did not restart
          command: |
            if [[ "$(ls /tmp/k8s-service-logs/stackrox/*-previous.log | wc -l)" != 0 ]]; then
                ls /tmp/k8s-service-logs/stackrox/*-previous.log
                exit 1
            fi
            cat nohup.out || true
          when: always

      - run-db-integration-tests

      - run:
          name: Collect k8s logs
          command: |
            .circleci/collect-service-logs.sh stackrox
            .circleci/collect-service-logs.sh kube-system
          when: always

      - run:
          name: Delete license and bounce pod
          command: |
            kubectl -n stackrox delete secret scanner-license
            POD="$(kubectl -n stackrox get pod -o jsonpath='{.items[?(@.metadata.labels.app=="scanner")].metadata.name}')"
            [[ -n "${POD}" ]]
            kubectl -n stackrox delete pod "${POD}"

      - wait-for-scanner-and-pf:
          condition: Initialized
          sleep-after-condition-met: 60

      - run:
          name: Run no license tests
          command: |
            make no-license-tests

      - run:
          name: Collect k8s logs
          command: |
            .circleci/collect-service-logs.sh stackrox
            .circleci/collect-service-logs.sh kube-system
          when: always

      - store_artifacts:
          path: /tmp/k8s-service-logs
          destination: k8s-service-logs-<< parameters.cluster-id >>

      - run:
          name: Verify the scanner did not restart
          command: |
            if [[ "$(ls /tmp/k8s-service-logs/stackrox/*-previous.log | wc -l)" != 0 ]]; then
                ls /tmp/k8s-service-logs/stackrox/*-previous.log
                exit 1
            fi
            cat nohup.out || true
          when: always

      - teardown-gke

  run-db-integration-tests:
    steps:
      - scanner-db-pf
      - run:
          name: Run db integration tests
          command: make db-integration-tests

jobs:
  unit-tests:
    <<: *defaults
    steps:
      - checkout

      - run:
          name: Install dependencies
          command: make deps

      - run:
          name: Run unit tests
          command: make unit-tests

  style-checks:
    <<: *defaults
    steps:
      - checkout

      - run:
          name: Install dependencies
          command: make deps

      - run:
          name: Run style checks
          command: make style

      - run:
          name: Run style checks on test code
          command: make -C qa-tests style

  generate-genesis-dump:
    <<: *defaults
    steps:
      - checkout
      - check-label-to-run:
          label: generate-dumps-on-pr
      - run:
          name: Build updater, and persist to workspace
          command: |
            make build-updater
            mkdir -p /tmp/updater-bin
            cp ./bin/updater /tmp/updater-bin/

      - run:
          name: Generate the genesis dump
          command: |
            mkdir -p /tmp/genesis-dump
            ./bin/updater generate-dump --out-file /tmp/genesis-dump/dump.zip
            ls -lrt /tmp/genesis-dump

      - run:
          name: Print some stats
          command: |
            ./bin/updater print-stats /tmp/genesis-dump/dump.zip

      - store_artifacts:
          path: /tmp/genesis-dump/dump.zip
          destination: genesis-dump.zip

      - persist_to_workspace:
          root: /tmp
          paths:
            - genesis-dump
            - updater-bin

  create-postgres-dump-from-genesis-dump:
    docker:
      - *defaultImage
      - image: postgres:11.6-alpine
    working_directory: *defaultWorkingDirectory
    steps:
      - checkout
      - check-label-to-run:
          label: generate-dumps-on-pr
      - setup_remote_docker
      - attach_workspace:
          at: /tmp

      - run:
          name: Restore updater bin
          command: |
            cp /tmp/updater-bin/updater ./bin/

      - run:
          name: Load vuln contents into postgres
          command: |
            ./bin/updater load-dump --postgres-host 127.0.0.1 --postgres-port 5432 --dump-file /tmp/genesis-dump/dump.zip

      - run:
          name: Take a PG dump
          command: |
            mkdir /tmp/postgres
            pg_dump -format=plain --no-owner --no-acl -U postgres postgres://127.0.0.1:5432 > /tmp/postgres/pg-definitions.sql
            gzip --best /tmp/postgres/pg-definitions.sql

      - store_artifacts:
          path: /tmp/postgres/pg-definitions.sql.gz
          destination: pg-definitions.sql.gz

      - persist_to_workspace:
          root: /tmp
          paths:
            - postgres

      - check-on-master-or-tag
      - setup-gcp
      - run:
          name: Upload PG dump to Google Storage
          command: |
            echo "On master or tag, uploading pg dump result to GCS"
            gsutil cp /tmp/postgres/pg-definitions.sql.gz gs://stackrox-scanner-ci-vuln-dump

  upload-dumps-for-embedding-into-image:
    <<: *defaults
    steps:
      - checkout
      - check-label-to-run:
          label: generate-dumps-on-pr

      - setup-gcp
      - attach_workspace:
          at: /tmp

      - run:
          name: Generate dumps
          command: |
            zip /tmp/genesis-dump/dump.zip 'nvd/*' --copy --out nvd-definitions.zip
            zip /tmp/genesis-dump/dump.zip 'k8s/*' --copy --out k8s-definitions.zip

      - run:
          name: Upload to Google Storage
          command: |
            cmd=()
            if [[ "${CIRCLE_BRANCH}" != "master" && -z "${CIRCLE_TAG}" ]]; then
              cmd+=(echo "Would do")
            fi
            "${cmd[@]}" gsutil cp nvd-definitions.zip gs://stackrox-scanner-ci-vuln-dump
            "${cmd[@]}" gsutil cp k8s-definitions.zip gs://stackrox-scanner-ci-vuln-dump

  create-diff-dumps:
    <<: *defaults
    resource_class: large
    steps:
      - checkout
      - check-label-to-run:
          label: generate-dumps-on-pr
      - setup-gcp
      - attach_workspace:
          at: /tmp

      - run:
          name: Restore updater bin
          command: |
            cp /tmp/updater-bin/updater ./bin/

      - run:
          name: Create diff for each manifest
          command: |
            mkdir -p /tmp/diff-dumps
            idx=-1
            while IFS=$'\t' read -r dumploc timestamp config; do
              idx=$((idx+1))
              dump_file_name="${dumploc##*/}"
              echo "Pulling genesis dump from ${dumploc}"
              gsutil cp "${dumploc}" .
              timestamp_in_zip="$(unzip -p "${dump_file_name}" manifest.json | jq -r '.until')"
              echo "Got timestamps -- from zip: ${timestamp_in_zip}; from manifest: ${timestamp}"
              [[ "${timestamp_in_zip}" == "${timestamp}" ]] # Assertion on the manifest contents
              ./bin/updater diff-dumps --base-dump "${dump_file_name}" --head-dump /tmp/genesis-dump/dump.zip --config "${config}" --out-file "/tmp/diff-dumps/dump${idx}/diff.zip"
            done < <(jq -r '.knownGenesisDumps | .[]| [.dumpLocationInGS, .timestamp, (.config // empty | tostring)] | @tsv' < image/scanner/dump/genesis_manifests.json)
            du -d 2 -kh "/tmp/diff-dumps"

      - persist_to_workspace:
          root: /tmp
          paths:
            - diff-dumps

  upload-diff-dumps-and-offline-dumps:
    <<: *defaults
    steps:
      - checkout
      - check-label-to-run:
          label: generate-dumps-on-pr
      - setup-gcp:
          service-account-env: GOOGLE_SA_STACKROX_HUB_VULN_DUMP_UPLOADER
      - attach_workspace:
          at: /tmp

      - run:
          name: Upload each diff dump to the prod bucket
          command: |
            idx=-1
            while IFS=$'\t' read -r diffloc; do
              idx=$((idx+1))
              expected_zip_file_loc="/tmp/diff-dumps/dump${idx}/diff.zip"
              [[ -f "${expected_zip_file_loc}" ]]
              if [[ -z "${diffloc}" ]]; then
                continue
              fi
              echo "Found file at ${expected_zip_file_loc}"
              du -skh "${expected_zip_file_loc}"
              cmd=()
              if [[ "${CIRCLE_BRANCH}" != "master" && -z "${CIRCLE_TAG}" ]]; then
                cmd+=(echo "Would do")
              fi
              "${cmd[@]}" gsutil cp "${expected_zip_file_loc}" "${diffloc}"
            done < <(jq -r '.knownGenesisDumps | .[]| [.diffLocation] | @tsv' < image/scanner/dump/genesis_manifests.json)

      - run:
          name: Generate offline dump
          command: |
            mkdir -p /tmp/offline-dump

            # Fetch the scanner dump which is marked as the base for offline dumps.
            # For offline dumps, we just use one base (the oldest base which is in a version of scanner still supported)
            # for simplicity.
            offline_dumps="$(jq '.knownGenesisDumps | map(.baseForOfflineDumps == true) | indices(true)' < image/scanner/dump/genesis_manifests.json)"
            echo "Got offline dumps list: ${offline_dumps}"
            [[ "$(echo "${offline_dumps}" | jq 'length')" -eq 1 ]]
            offline_diff_location="/tmp/diff-dumps/dump$(echo "${offline_dumps}" | jq -r '.[0]')/diff.zip"
            cp "${offline_diff_location}" /tmp/offline-dump/scanner-defs.zip

            # Prepare k8s and istio dump
            mkdir -p /tmp/scratch
            gsutil cp -r gs://definitions.stackrox.io/cve/* /tmp/scratch/
            cd /tmp/scratch
            zip -r /tmp/offline-dump/k8s-istio.zip *

            cd /tmp/offline-dump
            zip scanner-vuln-updates.zip scanner-defs.zip k8s-istio.zip
            du -skh scanner-vuln-updates.zip
            cmd=()
            if [[ "${CIRCLE_BRANCH}" != "master" && -z "${CIRCLE_TAG}" ]]; then
              cmd+=(echo "Would do")
            fi
            "${cmd[@]}" gsutil cp scanner-vuln-updates.zip gs://sr-roxc/scanner/scanner-vuln-updates.zip

  build:
    <<: *defaults
    steps:
      - build-and-push-image:
          make-image-target: image

  build-rhel:
    <<: *defaults
    steps:
      - build-and-push-image:
          make-image-target: image-rhel
          image-name-suffix: "-rhel"
      - run:
          name: Check if tagged
          command: |
            if [[ -z "$CIRCLE_TAG" ]]; then
                circleci step halt
                exit 0
            fi
      - setup-gcp
      - run:
          name: Upload rhel bundles
          command: |
            gcloud auth list
            tag="$(./get-tag)"
            GCP_DSOP_BUCKET="gs://dsop-artifacts.stackrox.io"
            gsutil cp "image/scanner/rhel/bundle.tar.gz" "${GCP_DSOP_BUCKET}/scanner-rhel/${tag}/"
            gsutil cp "image/db/rhel/bundle.tar.gz"      "${GCP_DSOP_BUCKET}/scanner-db-rhel/${tag}/"

  provision-cluster:
    <<: *defaults
    steps:
      - checkout
      - setup_remote_docker
      - provision-gke-cluster:
          cluster-id: alpine

  e2e-tests:
    <<: *defaults
    steps:
      - run-e2e-tests:
          cluster-id: alpine

  e2e-tests-rhel:
    <<: *defaults
    steps:
      - run-e2e-tests:
          cluster-id: rhel

  provision-cluster-rhel:
    <<: *defaults
    steps:
      - checkout
      - setup_remote_docker
      - provision-gke-cluster:
          cluster-id: rhel

  update-license-and-signing-keys-if-required:
    <<: *defaults
    steps:
      - checkout

      - add_ssh_keys:
          fingerprints:
            - "94:30:99:21:98:a6:ae:0d:25:ed:69:b2:19:9d:dc:02"

      - run:
          name: Export common variables
          command: |
            cci-export license_file_path chart/dev-license.lic
            cci-export temp_branch_name "roxbot-tmp/update-license-or-keys-${CIRCLE_BUILD_NUM}"
            cci-export branch_name "roxbot/update-license-or-keys-${CIRCLE_BUILD_NUM}"

      - run:
          name: Checkout rox code, copy dev license
          command: |
            git clone git@github.com:stackrox/rox.git /tmp/rox
            cp /tmp/rox/deploy/common/dev-license.lic "${license_file_path}"

      - run:
          name: Check if all_keys.go is different between the version of rox submoduled and HEAD
          command: |
            rox_dep="$(go mod graph | grep 'github.com/stackrox/scanner github.com/stackrox/rox')"
            echo "Got rox dep: ${rox_dep}"
            [[ -n "${rox_dep}" ]]
            # The above is a line like
            # github.com/stackrox/scanner github.com/stackrox/rox@v0.0.0-20200323210805-c398a933445c
            # The following line retrieves the last SHA (the component after the last dash)
            sha="${rox_dep##*-}"
            echo "Extracted SHA: ${sha}"
            [[ -n "${sha}" ]]
            set +e
            cd /tmp/rox
            git diff --exit-code "${sha}" -- pkg/license/publickeys/all_keys.go
            code=$?
            cd -
            set -e
            if [[ "${code}" -eq 1 ]]; then
              echo "Pulling in new signing keys from rox!"
              make deps
              go env -w GOPRIVATE=github.com/stackrox
              go get github.com/stackrox/rox@master
              go mod tidy
            else
              [[ "${code}" -eq 0 ]]
            fi

      - run:
          name: Exit early if there is no diff
          command: |
            if git diff --exit-code; then
              echo "No git diff, exiting now..."
              circleci step halt
            fi

      - run:
          name: Configure git
          command: |
            git config user.email "roxbot@stackrox.com"
            git config user.name "RoxBot"

      - run:
          name: Add SSH key of github.com
          command: |
            ssh-keyscan -H github.com >> ~/.ssh/known_hosts

      - run:
          name: Create temporary branch with new commit
          command: |
            git checkout -b "${temp_branch_name}"
            git commit \
              -am"Sync development license from rox ($(date '+%Y-%m-%d'))"

      - run:
          name: Push branch to remote
          command: |
            commit="$(git rev-parse "${temp_branch_name}")"

            git checkout master

            for i in $(seq 1 3); do
              echo "Attempting to merge into master (attempt $i of 3) ..."

              git fetch && git reset --hard origin/master
              # Note that the above `git reset --hard` requires a clean working tree. We therefore
              # cherry-pick the license update commit instead of generating it now such that we
              # invoke all scripts from the current branch (mostly relevant for testing purposes).
              git cherry-pick "$commit"
              if git push origin master:"${branch_name}"; then
                echo "Success!"
                exit 0
              fi

              echo "Push did not succeed. Sleeping for 10 seconds, then trying again."
              sleep 10
            done

            echo "Failed to merge into master."
            exit 1

      - run:
          name: Create PR
          command: |
            git checkout "$CIRCLE_BRANCH"
            .circleci/create-dev-license-update-pr.sh "${branch_name}"


workflows:
  version: 2

  update-license-and-signing-keys-if-required-daily:
    triggers:
      - schedule:
          cron: "0 0 * * *"
          filters:
            branches:
              only: master

    jobs:
      - update-license-and-signing-keys-if-required:
          <<: *runOnAllTagsWithDockerIOPullCtx

  update-dumps-hourly:
    triggers:
      - schedule:
          cron: "0 * * * *"
          filters:
            branches:
              only: master

    jobs:
      - generate-genesis-dump:
          <<: *runOnAllTagsWithDockerIOPullCtx
      - create-postgres-dump-from-genesis-dump:
          <<: *runOnAllTagsWithDockerIOPullCtx
          requires:
            - generate-genesis-dump
      - create-diff-dumps:
          <<: *runOnAllTagsWithDockerIOPullCtx
          requires:
            - generate-genesis-dump
      - upload-dumps-for-embedding-into-image:
          <<: *runOnAllTagsWithDockerIOPullCtx
          requires:
            - generate-genesis-dump
      - upload-diff-dumps-and-offline-dumps:
          <<: *runOnAllTagsWithDockerIOPullCtx
          requires:
            - create-diff-dumps
      - unit-tests:
          <<: *runOnAllTagsWithDockerIOPullCtx
      - style-checks:
          <<: *runOnAllTagsWithDockerIOPullCtx
      - build:
          <<: *runOnAllTags
          context: docker-io-and-stackrox-io-push
          requires:
            - create-postgres-dump-from-genesis-dump
            - upload-dumps-for-embedding-into-image
      - build-rhel:
          <<: *runOnAllTags
          context: docker-io-and-stackrox-io-push
          requires:
            - create-postgres-dump-from-genesis-dump
            - upload-dumps-for-embedding-into-image
      - provision-cluster:
          <<: *runOnAllTagsWithDockerIOPullCtx
      - e2e-tests:
          <<: *runOnAllTagsWithDockerIOPullCtx
          requires:
            - build
            - provision-cluster

  build:
    jobs:
    - generate-genesis-dump:
        <<: *runOnAllTagsWithDockerIOPullCtx
    - create-postgres-dump-from-genesis-dump:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
          - generate-genesis-dump
    - create-diff-dumps:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
          - generate-genesis-dump
    - upload-dumps-for-embedding-into-image:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
          - generate-genesis-dump
    - upload-diff-dumps-and-offline-dumps:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
          - create-diff-dumps
    - unit-tests:
        <<: *runOnAllTagsWithDockerIOPullCtx
    - style-checks:
        <<: *runOnAllTagsWithDockerIOPullCtx
    - build:
        <<: *runOnAllTags
        context: docker-io-and-stackrox-io-push
        requires:
          - create-postgres-dump-from-genesis-dump
          - upload-dumps-for-embedding-into-image
    - build-rhel:
        <<: *runOnAllTags
        context: docker-io-and-stackrox-io-push
        requires:
          - create-postgres-dump-from-genesis-dump
          - upload-dumps-for-embedding-into-image
    - provision-cluster:
        <<: *runOnAllTagsWithDockerIOPullCtx
    - provision-cluster-rhel:
        <<: *runOnAllTagsWithDockerIOPullCtx
    - e2e-tests:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
          - build
          - provision-cluster
    - e2e-tests-rhel:
        <<: *runOnAllTagsWithDockerIOPullCtx
        requires:
          - build-rhel
          - provision-cluster-rhel
