// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: shared/api/v1/image_scan_service.proto

package scannerV1

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SourceType int32

const (
	SourceType_UNSET_SOURCE_TYPE SourceType = 0
	SourceType_JAVA              SourceType = 1
	SourceType_PYTHON            SourceType = 2
	SourceType_NPM               SourceType = 3
	SourceType_GEM               SourceType = 4
	SourceType_DOTNETCORERUNTIME SourceType = 5
)

var SourceType_name = map[int32]string{
	0: "UNSET_SOURCE_TYPE",
	1: "JAVA",
	2: "PYTHON",
	3: "NPM",
	4: "GEM",
	5: "DOTNETCORERUNTIME",
}

var SourceType_value = map[string]int32{
	"UNSET_SOURCE_TYPE": 0,
	"JAVA":              1,
	"PYTHON":            2,
	"NPM":               3,
	"GEM":               4,
	"DOTNETCORERUNTIME": 5,
}

func (x SourceType) String() string {
	return proto.EnumName(SourceType_name, int32(x))
}

func (SourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21a8706899481053, []int{0}
}

type ScanStatus int32

const (
	ScanStatus_UNSET     ScanStatus = 0
	ScanStatus_ANALYZING ScanStatus = 1
	ScanStatus_FAILED    ScanStatus = 2
	ScanStatus_SUCCEEDED ScanStatus = 3
)

var ScanStatus_name = map[int32]string{
	0: "UNSET",
	1: "ANALYZING",
	2: "FAILED",
	3: "SUCCEEDED",
}

var ScanStatus_value = map[string]int32{
	"UNSET":     0,
	"ANALYZING": 1,
	"FAILED":    2,
	"SUCCEEDED": 3,
}

func (x ScanStatus) String() string {
	return proto.EnumName(ScanStatus_name, int32(x))
}

func (ScanStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21a8706899481053, []int{1}
}

type Image struct {
	Features             []*Feature `protobuf:"bytes,1,rep,name=features,proto3" json:"features,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Image) Reset()         { *m = Image{} }
func (m *Image) String() string { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()    {}
func (*Image) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a8706899481053, []int{0}
}
func (m *Image) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Image) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Image.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Image) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Image.Merge(m, src)
}
func (m *Image) XXX_Size() int {
	return m.Size()
}
func (m *Image) XXX_DiscardUnknown() {
	xxx_messageInfo_Image.DiscardUnknown(m)
}

var xxx_messageInfo_Image proto.InternalMessageInfo

func (m *Image) GetFeatures() []*Feature {
	if m != nil {
		return m.Features
	}
	return nil
}

func (m *Image) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Image) Clone() *Image {
	if m == nil {
		return nil
	}
	cloned := new(Image)
	*cloned = *m

	if m.Features != nil {
		cloned.Features = make([]*Feature, len(m.Features))
		for idx, v := range m.Features {
			cloned.Features[idx] = v.Clone()
		}
	}
	return cloned
}

type ScanImageRequest struct {
	Image                string                         `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	Registry             *ScanImageRequest_RegistryData `protobuf:"bytes,2,opt,name=registry,proto3" json:"registry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *ScanImageRequest) Reset()         { *m = ScanImageRequest{} }
func (m *ScanImageRequest) String() string { return proto.CompactTextString(m) }
func (*ScanImageRequest) ProtoMessage()    {}
func (*ScanImageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a8706899481053, []int{1}
}
func (m *ScanImageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanImageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanImageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanImageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanImageRequest.Merge(m, src)
}
func (m *ScanImageRequest) XXX_Size() int {
	return m.Size()
}
func (m *ScanImageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanImageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ScanImageRequest proto.InternalMessageInfo

func (m *ScanImageRequest) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ScanImageRequest) GetRegistry() *ScanImageRequest_RegistryData {
	if m != nil {
		return m.Registry
	}
	return nil
}

func (m *ScanImageRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ScanImageRequest) Clone() *ScanImageRequest {
	if m == nil {
		return nil
	}
	cloned := new(ScanImageRequest)
	*cloned = *m

	cloned.Registry = m.Registry.Clone()
	return cloned
}

type ScanImageRequest_RegistryData struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Insecure             bool     `protobuf:"varint,4,opt,name=insecure,proto3" json:"insecure,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ScanImageRequest_RegistryData) Reset()         { *m = ScanImageRequest_RegistryData{} }
func (m *ScanImageRequest_RegistryData) String() string { return proto.CompactTextString(m) }
func (*ScanImageRequest_RegistryData) ProtoMessage()    {}
func (*ScanImageRequest_RegistryData) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a8706899481053, []int{1, 0}
}
func (m *ScanImageRequest_RegistryData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanImageRequest_RegistryData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanImageRequest_RegistryData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanImageRequest_RegistryData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanImageRequest_RegistryData.Merge(m, src)
}
func (m *ScanImageRequest_RegistryData) XXX_Size() int {
	return m.Size()
}
func (m *ScanImageRequest_RegistryData) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanImageRequest_RegistryData.DiscardUnknown(m)
}

var xxx_messageInfo_ScanImageRequest_RegistryData proto.InternalMessageInfo

func (m *ScanImageRequest_RegistryData) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ScanImageRequest_RegistryData) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *ScanImageRequest_RegistryData) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *ScanImageRequest_RegistryData) GetInsecure() bool {
	if m != nil {
		return m.Insecure
	}
	return false
}

func (m *ScanImageRequest_RegistryData) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ScanImageRequest_RegistryData) Clone() *ScanImageRequest_RegistryData {
	if m == nil {
		return nil
	}
	cloned := new(ScanImageRequest_RegistryData)
	*cloned = *m

	return cloned
}

type ScanImageResponse struct {
	Status               ScanStatus `protobuf:"varint,1,opt,name=status,proto3,enum=scannerV1.ScanStatus" json:"status,omitempty"`
	Image                *ImageSpec `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ScanImageResponse) Reset()         { *m = ScanImageResponse{} }
func (m *ScanImageResponse) String() string { return proto.CompactTextString(m) }
func (*ScanImageResponse) ProtoMessage()    {}
func (*ScanImageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a8706899481053, []int{2}
}
func (m *ScanImageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanImageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanImageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanImageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanImageResponse.Merge(m, src)
}
func (m *ScanImageResponse) XXX_Size() int {
	return m.Size()
}
func (m *ScanImageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanImageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ScanImageResponse proto.InternalMessageInfo

func (m *ScanImageResponse) GetStatus() ScanStatus {
	if m != nil {
		return m.Status
	}
	return ScanStatus_UNSET
}

func (m *ScanImageResponse) GetImage() *ImageSpec {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *ScanImageResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ScanImageResponse) Clone() *ScanImageResponse {
	if m == nil {
		return nil
	}
	cloned := new(ScanImageResponse)
	*cloned = *m

	cloned.Image = m.Image.Clone()
	return cloned
}

type ImageSpec struct {
	Digest               string   `protobuf:"bytes,1,opt,name=digest,proto3" json:"digest,omitempty"`
	Image                string   `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageSpec) Reset()         { *m = ImageSpec{} }
func (m *ImageSpec) String() string { return proto.CompactTextString(m) }
func (*ImageSpec) ProtoMessage()    {}
func (*ImageSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a8706899481053, []int{3}
}
func (m *ImageSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImageSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImageSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImageSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageSpec.Merge(m, src)
}
func (m *ImageSpec) XXX_Size() int {
	return m.Size()
}
func (m *ImageSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ImageSpec proto.InternalMessageInfo

func (m *ImageSpec) GetDigest() string {
	if m != nil {
		return m.Digest
	}
	return ""
}

func (m *ImageSpec) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ImageSpec) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ImageSpec) Clone() *ImageSpec {
	if m == nil {
		return nil
	}
	cloned := new(ImageSpec)
	*cloned = *m

	return cloned
}

type GetImageScanRequest struct {
	// Only one of the fields in ImageSpec needs to be set for the request to be properly formed
	// If both are set, then digest is used
	ImageSpec            *ImageSpec `protobuf:"bytes,1,opt,name=image_spec,json=imageSpec,proto3" json:"image_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetImageScanRequest) Reset()         { *m = GetImageScanRequest{} }
func (m *GetImageScanRequest) String() string { return proto.CompactTextString(m) }
func (*GetImageScanRequest) ProtoMessage()    {}
func (*GetImageScanRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a8706899481053, []int{4}
}
func (m *GetImageScanRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetImageScanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetImageScanRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetImageScanRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetImageScanRequest.Merge(m, src)
}
func (m *GetImageScanRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetImageScanRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetImageScanRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetImageScanRequest proto.InternalMessageInfo

func (m *GetImageScanRequest) GetImageSpec() *ImageSpec {
	if m != nil {
		return m.ImageSpec
	}
	return nil
}

func (m *GetImageScanRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetImageScanRequest) Clone() *GetImageScanRequest {
	if m == nil {
		return nil
	}
	cloned := new(GetImageScanRequest)
	*cloned = *m

	cloned.ImageSpec = m.ImageSpec.Clone()
	return cloned
}

type GetLanguageLevelComponentsRequest struct {
	// Only one of the fields in ImageSpec needs to be set for the request to be properly formed
	// If both are set, then digest is used
	ImageSpec            *ImageSpec `protobuf:"bytes,1,opt,name=image_spec,json=imageSpec,proto3" json:"image_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetLanguageLevelComponentsRequest) Reset()         { *m = GetLanguageLevelComponentsRequest{} }
func (m *GetLanguageLevelComponentsRequest) String() string { return proto.CompactTextString(m) }
func (*GetLanguageLevelComponentsRequest) ProtoMessage()    {}
func (*GetLanguageLevelComponentsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a8706899481053, []int{5}
}
func (m *GetLanguageLevelComponentsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLanguageLevelComponentsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLanguageLevelComponentsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLanguageLevelComponentsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLanguageLevelComponentsRequest.Merge(m, src)
}
func (m *GetLanguageLevelComponentsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLanguageLevelComponentsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLanguageLevelComponentsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLanguageLevelComponentsRequest proto.InternalMessageInfo

func (m *GetLanguageLevelComponentsRequest) GetImageSpec() *ImageSpec {
	if m != nil {
		return m.ImageSpec
	}
	return nil
}

func (m *GetLanguageLevelComponentsRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetLanguageLevelComponentsRequest) Clone() *GetLanguageLevelComponentsRequest {
	if m == nil {
		return nil
	}
	cloned := new(GetLanguageLevelComponentsRequest)
	*cloned = *m

	cloned.ImageSpec = m.ImageSpec.Clone()
	return cloned
}

type LanguageLevelComponent struct {
	SourceType           SourceType `protobuf:"varint,1,opt,name=source_type,json=sourceType,proto3,enum=scannerV1.SourceType" json:"source_type,omitempty"`
	Name                 string     `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Version              string     `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	Location             string     `protobuf:"bytes,4,opt,name=location,proto3" json:"location,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *LanguageLevelComponent) Reset()         { *m = LanguageLevelComponent{} }
func (m *LanguageLevelComponent) String() string { return proto.CompactTextString(m) }
func (*LanguageLevelComponent) ProtoMessage()    {}
func (*LanguageLevelComponent) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a8706899481053, []int{6}
}
func (m *LanguageLevelComponent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LanguageLevelComponent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LanguageLevelComponent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LanguageLevelComponent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LanguageLevelComponent.Merge(m, src)
}
func (m *LanguageLevelComponent) XXX_Size() int {
	return m.Size()
}
func (m *LanguageLevelComponent) XXX_DiscardUnknown() {
	xxx_messageInfo_LanguageLevelComponent.DiscardUnknown(m)
}

var xxx_messageInfo_LanguageLevelComponent proto.InternalMessageInfo

func (m *LanguageLevelComponent) GetSourceType() SourceType {
	if m != nil {
		return m.SourceType
	}
	return SourceType_UNSET_SOURCE_TYPE
}

func (m *LanguageLevelComponent) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LanguageLevelComponent) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *LanguageLevelComponent) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *LanguageLevelComponent) MessageClone() proto.Message {
	return m.Clone()
}
func (m *LanguageLevelComponent) Clone() *LanguageLevelComponent {
	if m == nil {
		return nil
	}
	cloned := new(LanguageLevelComponent)
	*cloned = *m

	return cloned
}

type LanguageLevelComponents struct {
	Components           []*LanguageLevelComponent `protobuf:"bytes,1,rep,name=components,proto3" json:"components,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *LanguageLevelComponents) Reset()         { *m = LanguageLevelComponents{} }
func (m *LanguageLevelComponents) String() string { return proto.CompactTextString(m) }
func (*LanguageLevelComponents) ProtoMessage()    {}
func (*LanguageLevelComponents) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a8706899481053, []int{7}
}
func (m *LanguageLevelComponents) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LanguageLevelComponents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LanguageLevelComponents.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LanguageLevelComponents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LanguageLevelComponents.Merge(m, src)
}
func (m *LanguageLevelComponents) XXX_Size() int {
	return m.Size()
}
func (m *LanguageLevelComponents) XXX_DiscardUnknown() {
	xxx_messageInfo_LanguageLevelComponents.DiscardUnknown(m)
}

var xxx_messageInfo_LanguageLevelComponents proto.InternalMessageInfo

func (m *LanguageLevelComponents) GetComponents() []*LanguageLevelComponent {
	if m != nil {
		return m.Components
	}
	return nil
}

func (m *LanguageLevelComponents) MessageClone() proto.Message {
	return m.Clone()
}
func (m *LanguageLevelComponents) Clone() *LanguageLevelComponents {
	if m == nil {
		return nil
	}
	cloned := new(LanguageLevelComponents)
	*cloned = *m

	if m.Components != nil {
		cloned.Components = make([]*LanguageLevelComponent, len(m.Components))
		for idx, v := range m.Components {
			cloned.Components[idx] = v.Clone()
		}
	}
	return cloned
}

type GetLanguageLevelComponentsResponse struct {
	LayerToComponents    map[string]*LanguageLevelComponents `protobuf:"bytes,1,rep,name=layer_to_components,json=layerToComponents,proto3" json:"layer_to_components,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *GetLanguageLevelComponentsResponse) Reset()         { *m = GetLanguageLevelComponentsResponse{} }
func (m *GetLanguageLevelComponentsResponse) String() string { return proto.CompactTextString(m) }
func (*GetLanguageLevelComponentsResponse) ProtoMessage()    {}
func (*GetLanguageLevelComponentsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a8706899481053, []int{8}
}
func (m *GetLanguageLevelComponentsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLanguageLevelComponentsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLanguageLevelComponentsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLanguageLevelComponentsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLanguageLevelComponentsResponse.Merge(m, src)
}
func (m *GetLanguageLevelComponentsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetLanguageLevelComponentsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLanguageLevelComponentsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLanguageLevelComponentsResponse proto.InternalMessageInfo

func (m *GetLanguageLevelComponentsResponse) GetLayerToComponents() map[string]*LanguageLevelComponents {
	if m != nil {
		return m.LayerToComponents
	}
	return nil
}

func (m *GetLanguageLevelComponentsResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetLanguageLevelComponentsResponse) Clone() *GetLanguageLevelComponentsResponse {
	if m == nil {
		return nil
	}
	cloned := new(GetLanguageLevelComponentsResponse)
	*cloned = *m

	if m.LayerToComponents != nil {
		cloned.LayerToComponents = make(map[string]*LanguageLevelComponents, len(m.LayerToComponents))
		for k, v := range m.LayerToComponents {
			cloned.LayerToComponents[k] = v.Clone()
		}
	}
	return cloned
}

type GetImageScanResponse struct {
	Status               ScanStatus `protobuf:"varint,1,opt,name=status,proto3,enum=scannerV1.ScanStatus" json:"status,omitempty"`
	Image                *Image     `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetImageScanResponse) Reset()         { *m = GetImageScanResponse{} }
func (m *GetImageScanResponse) String() string { return proto.CompactTextString(m) }
func (*GetImageScanResponse) ProtoMessage()    {}
func (*GetImageScanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a8706899481053, []int{9}
}
func (m *GetImageScanResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetImageScanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetImageScanResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetImageScanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetImageScanResponse.Merge(m, src)
}
func (m *GetImageScanResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetImageScanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetImageScanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetImageScanResponse proto.InternalMessageInfo

func (m *GetImageScanResponse) GetStatus() ScanStatus {
	if m != nil {
		return m.Status
	}
	return ScanStatus_UNSET
}

func (m *GetImageScanResponse) GetImage() *Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *GetImageScanResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetImageScanResponse) Clone() *GetImageScanResponse {
	if m == nil {
		return nil
	}
	cloned := new(GetImageScanResponse)
	*cloned = *m

	cloned.Image = m.Image.Clone()
	return cloned
}

func init() {
	proto.RegisterEnum("scannerV1.SourceType", SourceType_name, SourceType_value)
	proto.RegisterEnum("scannerV1.ScanStatus", ScanStatus_name, ScanStatus_value)
	proto.RegisterType((*Image)(nil), "scannerV1.Image")
	proto.RegisterType((*ScanImageRequest)(nil), "scannerV1.ScanImageRequest")
	proto.RegisterType((*ScanImageRequest_RegistryData)(nil), "scannerV1.ScanImageRequest.RegistryData")
	proto.RegisterType((*ScanImageResponse)(nil), "scannerV1.ScanImageResponse")
	proto.RegisterType((*ImageSpec)(nil), "scannerV1.ImageSpec")
	proto.RegisterType((*GetImageScanRequest)(nil), "scannerV1.GetImageScanRequest")
	proto.RegisterType((*GetLanguageLevelComponentsRequest)(nil), "scannerV1.GetLanguageLevelComponentsRequest")
	proto.RegisterType((*LanguageLevelComponent)(nil), "scannerV1.LanguageLevelComponent")
	proto.RegisterType((*LanguageLevelComponents)(nil), "scannerV1.LanguageLevelComponents")
	proto.RegisterType((*GetLanguageLevelComponentsResponse)(nil), "scannerV1.GetLanguageLevelComponentsResponse")
	proto.RegisterMapType((map[string]*LanguageLevelComponents)(nil), "scannerV1.GetLanguageLevelComponentsResponse.LayerToComponentsEntry")
	proto.RegisterType((*GetImageScanResponse)(nil), "scannerV1.GetImageScanResponse")
}

func init() {
	proto.RegisterFile("shared/api/v1/image_scan_service.proto", fileDescriptor_21a8706899481053)
}

var fileDescriptor_21a8706899481053 = []byte{
	// 869 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0x5f, 0x6f, 0x1b, 0x45,
	0x10, 0xcf, 0xd9, 0x71, 0xea, 0x9b, 0x14, 0xb8, 0x6c, 0xd3, 0xd6, 0x3a, 0x8a, 0xeb, 0x9c, 0x44,
	0x65, 0x45, 0xf4, 0xa2, 0xa4, 0x12, 0x94, 0x4a, 0x3c, 0x18, 0xfb, 0x1a, 0x52, 0x39, 0x4e, 0x74,
	0x76, 0xaa, 0xa6, 0x42, 0xb2, 0x36, 0x97, 0xc1, 0x39, 0xe5, 0xb2, 0x7b, 0xec, 0xee, 0x19, 0xfc,
	0x0a, 0x7c, 0x03, 0x5e, 0x10, 0x4f, 0x7c, 0x1c, 0x1e, 0x91, 0xf8, 0x02, 0x28, 0xf4, 0x83, 0xa0,
	0xfb, 0xe3, 0xf3, 0xc5, 0x38, 0x0d, 0x7f, 0xde, 0x66, 0xf6, 0x37, 0x33, 0xbf, 0xd9, 0xf9, 0xb3,
	0x0b, 0x8f, 0xe4, 0x19, 0x15, 0x78, 0xba, 0x45, 0x43, 0x7f, 0x6b, 0xbc, 0xbd, 0xe5, 0x5f, 0xd0,
	0x11, 0x0e, 0xa5, 0x47, 0xd9, 0x50, 0xa2, 0x18, 0xfb, 0x1e, 0xda, 0xa1, 0xe0, 0x8a, 0x13, 0x3d,
	0x3e, 0x63, 0x28, 0x5e, 0x6e, 0x9b, 0x0f, 0x46, 0x9c, 0x8f, 0x02, 0x4c, 0x5c, 0x28, 0x63, 0x5c,
	0x51, 0xe5, 0x73, 0x26, 0x53, 0x43, 0x73, 0xe3, 0x6a, 0xc0, 0x71, 0x14, 0x30, 0x14, 0xf4, 0xc4,
	0x0f, 0x7c, 0x35, 0x49, 0x4d, 0xac, 0x4f, 0xa0, 0xb2, 0x17, 0xf3, 0x10, 0x1b, 0xaa, 0x5f, 0x21,
	0x55, 0x91, 0x40, 0x59, 0xd3, 0x1a, 0xe5, 0xe6, 0xea, 0x0e, 0xb1, 0x73, 0x1e, 0xfb, 0x79, 0x0a,
	0xb9, 0xb9, 0x8d, 0xf5, 0x46, 0x03, 0xa3, 0xef, 0x51, 0x96, 0x78, 0xbb, 0xf8, 0x75, 0x84, 0x52,
	0x91, 0x75, 0xa8, 0x24, 0x59, 0xd7, 0xb4, 0x86, 0xd6, 0xd4, 0xdd, 0x54, 0x21, 0x1d, 0xa8, 0x0a,
	0x1c, 0xf9, 0x52, 0x89, 0x49, 0xad, 0xd4, 0xd0, 0x9a, 0xab, 0x3b, 0xcd, 0x42, 0xe8, 0xf9, 0x20,
	0xb6, 0x9b, 0xd9, 0x76, 0xa8, 0xa2, 0x6e, 0xee, 0x69, 0x2a, 0xb8, 0x5d, 0x44, 0x88, 0x01, 0xe5,
	0x48, 0x04, 0x19, 0x53, 0x2c, 0x12, 0x13, 0xaa, 0x91, 0x44, 0xc1, 0xe8, 0x05, 0x26, 0x3c, 0xba,
	0x9b, 0xeb, 0x31, 0x16, 0x52, 0x29, 0xbf, 0xe1, 0xe2, 0xb4, 0x56, 0x4e, 0xb1, 0xa9, 0x1e, 0x63,
	0x3e, 0x93, 0xe8, 0x45, 0x02, 0x6b, 0xcb, 0x0d, 0xad, 0x59, 0x75, 0x73, 0xdd, 0x62, 0xb0, 0x56,
	0x48, 0x50, 0x86, 0x9c, 0x49, 0x24, 0x8f, 0x61, 0x45, 0x2a, 0xaa, 0x22, 0x99, 0xb0, 0xbf, 0xbb,
	0x73, 0x77, 0xee, 0x3a, 0xfd, 0x04, 0x74, 0x33, 0x23, 0xb2, 0x39, 0xad, 0x4a, 0x7a, 0xf9, 0xf5,
	0x82, 0x75, 0x12, 0xb7, 0x1f, 0xa2, 0x97, 0xd5, 0xca, 0xfa, 0x14, 0xf4, 0xfc, 0x8c, 0xdc, 0x83,
	0x95, 0x53, 0x7f, 0x84, 0x52, 0x65, 0xb7, 0xcc, 0xb4, 0x59, 0x99, 0x4b, 0x85, 0x32, 0x5b, 0x2f,
	0xe0, 0xce, 0x2e, 0xaa, 0xd4, 0xdb, 0xa3, 0x6c, 0xda, 0x93, 0x27, 0x00, 0xd9, 0x24, 0x85, 0xe8,
	0x25, 0x81, 0xae, 0x4b, 0x41, 0xf7, 0xa7, 0xa2, 0xf5, 0x0a, 0x36, 0x76, 0x51, 0x75, 0x29, 0x1b,
	0x45, 0x74, 0x84, 0x5d, 0x1c, 0x63, 0xd0, 0xe6, 0x17, 0x21, 0x67, 0xc8, 0x94, 0xfc, 0x5f, 0x91,
	0x7f, 0xd6, 0xe0, 0xde, 0xe2, 0xb8, 0xe4, 0x63, 0x58, 0x95, 0x3c, 0x12, 0x1e, 0x0e, 0xd5, 0x24,
	0xc4, 0x45, 0xb5, 0x4d, 0xd0, 0xc1, 0x24, 0x44, 0x17, 0x64, 0x2e, 0x13, 0x02, 0xcb, 0x85, 0x9e,
	0x27, 0x32, 0xa9, 0xc1, 0xad, 0x31, 0x0a, 0xe9, 0x73, 0x96, 0xb5, 0x7b, 0xaa, 0xc6, 0xdd, 0x0e,
	0xb8, 0x97, 0xec, 0x49, 0xd2, 0x6d, 0xdd, 0xcd, 0x75, 0xeb, 0x4b, 0xb8, 0x7f, 0xcd, 0x9d, 0x49,
	0x0b, 0xc0, 0xcb, 0xb5, 0x6c, 0x43, 0x36, 0x0a, 0xb9, 0x2d, 0xf6, 0x73, 0x0b, 0x4e, 0xd6, 0x0f,
	0x25, 0xb0, 0xde, 0x56, 0xd5, 0x6c, 0xba, 0x14, 0xdc, 0x09, 0xe8, 0x04, 0xc5, 0x50, 0xf1, 0xe1,
	0xdf, 0x28, 0x3b, 0x05, 0xca, 0x9b, 0x63, 0xd9, 0xdd, 0x38, 0xd0, 0x80, 0xcf, 0x10, 0x87, 0x29,
	0x31, 0x71, 0xd7, 0x82, 0xf9, 0x73, 0xf3, 0x2c, 0x6e, 0xcb, 0x22, 0xe3, 0x78, 0xd1, 0xce, 0x71,
	0x32, 0x5d, 0xb4, 0x73, 0x9c, 0x90, 0xa7, 0x50, 0x19, 0xd3, 0x20, 0x9a, 0x0e, 0xb4, 0x75, 0x63,
	0x19, 0xa4, 0x9b, 0x3a, 0x3c, 0x2b, 0x3d, 0xd5, 0xac, 0x0b, 0x58, 0xbf, 0x3a, 0xa7, 0xff, 0x6d,
	0xab, 0x1e, 0x5d, 0xdd, 0x2a, 0x63, 0x7e, 0xf0, 0xb2, 0xb5, 0xd8, 0x3c, 0x01, 0x98, 0xcd, 0x0d,
	0xb9, 0x0b, 0x6b, 0x47, 0xbd, 0xbe, 0x33, 0x18, 0xf6, 0x0f, 0x8e, 0xdc, 0xb6, 0x33, 0x1c, 0x1c,
	0x1f, 0x3a, 0xc6, 0x12, 0xa9, 0xc2, 0xf2, 0x8b, 0xd6, 0xcb, 0x96, 0xa1, 0x11, 0x80, 0x95, 0xc3,
	0xe3, 0xc1, 0x17, 0x07, 0x3d, 0xa3, 0x44, 0x6e, 0x41, 0xb9, 0x77, 0xb8, 0x6f, 0x94, 0x63, 0x61,
	0xd7, 0xd9, 0x37, 0x96, 0x63, 0xf7, 0xce, 0xc1, 0xa0, 0xe7, 0x0c, 0xda, 0x07, 0xae, 0xe3, 0x1e,
	0xf5, 0x06, 0x7b, 0xfb, 0x8e, 0x51, 0xd9, 0x6c, 0x01, 0xcc, 0x32, 0x24, 0x3a, 0x54, 0x12, 0x0e,
	0x63, 0x89, 0xbc, 0x03, 0x7a, 0xab, 0xd7, 0xea, 0x1e, 0xbf, 0xde, 0xeb, 0xed, 0xa6, 0xc1, 0x9f,
	0xb7, 0xf6, 0xba, 0x4e, 0xc7, 0x28, 0xc5, 0x50, 0xff, 0xa8, 0xdd, 0x76, 0x9c, 0x8e, 0xd3, 0x31,
	0xca, 0x3b, 0xdf, 0x97, 0xc1, 0xc8, 0x6b, 0xd2, 0x4f, 0xdf, 0x7b, 0x72, 0x02, 0x7a, 0xfe, 0xfa,
	0x90, 0xf7, 0xdf, 0xf2, 0x68, 0x9a, 0x0f, 0x16, 0x83, 0x69, 0x69, 0x2d, 0xf3, 0xbb, 0xdf, 0xdf,
	0xfc, 0x58, 0x5a, 0xb7, 0xde, 0xcb, 0xff, 0x15, 0xb9, 0x15, 0xdb, 0x3f, 0xd3, 0x36, 0xc9, 0x19,
	0xdc, 0x2e, 0xb6, 0x83, 0xd4, 0xaf, 0x4e, 0xd8, 0xfc, 0x7b, 0x62, 0x3e, 0xbc, 0x16, 0xcf, 0xc8,
	0xee, 0x27, 0x64, 0x6b, 0x64, 0x9e, 0x8c, 0xfc, 0xa2, 0x81, 0x79, 0xfd, 0xcc, 0x92, 0x8f, 0xfe,
	0xe1, 0x68, 0xa7, 0x69, 0x3c, 0xfe, 0x57, 0x8b, 0x60, 0x7d, 0x98, 0x24, 0xf5, 0x90, 0x7c, 0x50,
	0x48, 0x2a, 0xc8, 0x7c, 0x66, 0x4b, 0xf6, 0xf9, 0x67, 0xbf, 0x5e, 0xd6, 0xb5, 0xdf, 0x2e, 0xeb,
	0xda, 0x1f, 0x97, 0x75, 0xed, 0xa7, 0x3f, 0xeb, 0x4b, 0xd0, 0xf0, 0xb9, 0x2d, 0x15, 0xf5, 0xce,
	0x05, 0xff, 0x36, 0xfd, 0x33, 0x6d, 0x1a, 0xfa, 0x53, 0x72, 0x7b, 0xbc, 0xfd, 0x7a, 0xf6, 0x1d,
	0xbf, 0x5a, 0x3a, 0x59, 0x49, 0x4c, 0x9e, 0xfc, 0x15, 0x00, 0x00, 0xff, 0xff, 0xff, 0x6a, 0x79,
	0x02, 0xcc, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ImageScanServiceClient is the client API for ImageScanService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConnInterface.NewStream.
type ImageScanServiceClient interface {
	ScanImage(ctx context.Context, in *ScanImageRequest, opts ...grpc.CallOption) (*ScanImageResponse, error)
	GetImageScan(ctx context.Context, in *GetImageScanRequest, opts ...grpc.CallOption) (*GetImageScanResponse, error)
	GetLanguageLevelComponents(ctx context.Context, in *GetLanguageLevelComponentsRequest, opts ...grpc.CallOption) (*GetLanguageLevelComponentsResponse, error)
}

type imageScanServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewImageScanServiceClient(cc grpc.ClientConnInterface) ImageScanServiceClient {
	return &imageScanServiceClient{cc}
}

func (c *imageScanServiceClient) ScanImage(ctx context.Context, in *ScanImageRequest, opts ...grpc.CallOption) (*ScanImageResponse, error) {
	out := new(ScanImageResponse)
	err := c.cc.Invoke(ctx, "/scannerV1.ImageScanService/ScanImage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageScanServiceClient) GetImageScan(ctx context.Context, in *GetImageScanRequest, opts ...grpc.CallOption) (*GetImageScanResponse, error) {
	out := new(GetImageScanResponse)
	err := c.cc.Invoke(ctx, "/scannerV1.ImageScanService/GetImageScan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imageScanServiceClient) GetLanguageLevelComponents(ctx context.Context, in *GetLanguageLevelComponentsRequest, opts ...grpc.CallOption) (*GetLanguageLevelComponentsResponse, error) {
	out := new(GetLanguageLevelComponentsResponse)
	err := c.cc.Invoke(ctx, "/scannerV1.ImageScanService/GetLanguageLevelComponents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImageScanServiceServer is the server API for ImageScanService service.
type ImageScanServiceServer interface {
	ScanImage(context.Context, *ScanImageRequest) (*ScanImageResponse, error)
	GetImageScan(context.Context, *GetImageScanRequest) (*GetImageScanResponse, error)
	GetLanguageLevelComponents(context.Context, *GetLanguageLevelComponentsRequest) (*GetLanguageLevelComponentsResponse, error)
}

// UnimplementedImageScanServiceServer can be embedded to have forward compatible implementations.
type UnimplementedImageScanServiceServer struct {
}

func (*UnimplementedImageScanServiceServer) ScanImage(ctx context.Context, req *ScanImageRequest) (*ScanImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScanImage not implemented")
}
func (*UnimplementedImageScanServiceServer) GetImageScan(ctx context.Context, req *GetImageScanRequest) (*GetImageScanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImageScan not implemented")
}
func (*UnimplementedImageScanServiceServer) GetLanguageLevelComponents(ctx context.Context, req *GetLanguageLevelComponentsRequest) (*GetLanguageLevelComponentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLanguageLevelComponents not implemented")
}

func RegisterImageScanServiceServer(s *grpc.Server, srv ImageScanServiceServer) {
	s.RegisterService(&_ImageScanService_serviceDesc, srv)
}

func _ImageScanService_ScanImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScanImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageScanServiceServer).ScanImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scannerV1.ImageScanService/ScanImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageScanServiceServer).ScanImage(ctx, req.(*ScanImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageScanService_GetImageScan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImageScanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageScanServiceServer).GetImageScan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scannerV1.ImageScanService/GetImageScan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageScanServiceServer).GetImageScan(ctx, req.(*GetImageScanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImageScanService_GetLanguageLevelComponents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLanguageLevelComponentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageScanServiceServer).GetLanguageLevelComponents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scannerV1.ImageScanService/GetLanguageLevelComponents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageScanServiceServer).GetLanguageLevelComponents(ctx, req.(*GetLanguageLevelComponentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ImageScanService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "scannerV1.ImageScanService",
	HandlerType: (*ImageScanServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ScanImage",
			Handler:    _ImageScanService_ScanImage_Handler,
		},
		{
			MethodName: "GetImageScan",
			Handler:    _ImageScanService_GetImageScan_Handler,
		},
		{
			MethodName: "GetLanguageLevelComponents",
			Handler:    _ImageScanService_GetLanguageLevelComponents_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "shared/api/v1/image_scan_service.proto",
}

func (m *Image) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Image) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Image) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Features) > 0 {
		for iNdEx := len(m.Features) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Features[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintImageScanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ScanImageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanImageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanImageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Registry != nil {
		{
			size, err := m.Registry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintImageScanService(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScanImageRequest_RegistryData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanImageRequest_RegistryData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanImageRequest_RegistryData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Insecure {
		i--
		if m.Insecure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintImageScanService(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintImageScanService(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintImageScanService(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScanImageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanImageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanImageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintImageScanService(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImageSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintImageScanService(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Digest) > 0 {
		i -= len(m.Digest)
		copy(dAtA[i:], m.Digest)
		i = encodeVarintImageScanService(dAtA, i, uint64(len(m.Digest)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetImageScanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetImageScanRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetImageScanRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ImageSpec != nil {
		{
			size, err := m.ImageSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLanguageLevelComponentsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLanguageLevelComponentsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLanguageLevelComponentsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ImageSpec != nil {
		{
			size, err := m.ImageSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LanguageLevelComponent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LanguageLevelComponent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LanguageLevelComponent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintImageScanService(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintImageScanService(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintImageScanService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.SourceType != 0 {
		i = encodeVarintImageScanService(dAtA, i, uint64(m.SourceType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LanguageLevelComponents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LanguageLevelComponents) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LanguageLevelComponents) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Components) > 0 {
		for iNdEx := len(m.Components) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Components[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintImageScanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetLanguageLevelComponentsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLanguageLevelComponentsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLanguageLevelComponentsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LayerToComponents) > 0 {
		for k := range m.LayerToComponents {
			v := m.LayerToComponents[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintImageScanService(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintImageScanService(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintImageScanService(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetImageScanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetImageScanResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetImageScanResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintImageScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintImageScanService(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintImageScanService(dAtA []byte, offset int, v uint64) int {
	offset -= sovImageScanService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Image) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Features) > 0 {
		for _, e := range m.Features {
			l = e.Size()
			n += 1 + l + sovImageScanService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScanImageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovImageScanService(uint64(l))
	}
	if m.Registry != nil {
		l = m.Registry.Size()
		n += 1 + l + sovImageScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScanImageRequest_RegistryData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovImageScanService(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovImageScanService(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovImageScanService(uint64(l))
	}
	if m.Insecure {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScanImageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovImageScanService(uint64(m.Status))
	}
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovImageScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ImageSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovImageScanService(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovImageScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetImageScanRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImageSpec != nil {
		l = m.ImageSpec.Size()
		n += 1 + l + sovImageScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLanguageLevelComponentsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImageSpec != nil {
		l = m.ImageSpec.Size()
		n += 1 + l + sovImageScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LanguageLevelComponent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourceType != 0 {
		n += 1 + sovImageScanService(uint64(m.SourceType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovImageScanService(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovImageScanService(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovImageScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LanguageLevelComponents) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Components) > 0 {
		for _, e := range m.Components {
			l = e.Size()
			n += 1 + l + sovImageScanService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLanguageLevelComponentsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LayerToComponents) > 0 {
		for k, v := range m.LayerToComponents {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovImageScanService(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovImageScanService(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovImageScanService(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetImageScanResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovImageScanService(uint64(m.Status))
	}
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovImageScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovImageScanService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozImageScanService(x uint64) (n int) {
	return sovImageScanService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Image) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Features = append(m.Features, &Feature{})
			if err := m.Features[len(m.Features)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanImageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanImageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanImageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Registry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Registry == nil {
				m.Registry = &ScanImageRequest_RegistryData{}
			}
			if err := m.Registry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanImageRequest_RegistryData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegistryData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegistryData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Insecure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Insecure = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImageScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanImageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanImageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanImageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ScanStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &ImageSpec{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetImageScanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetImageScanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetImageScanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageSpec == nil {
				m.ImageSpec = &ImageSpec{}
			}
			if err := m.ImageSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLanguageLevelComponentsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLanguageLevelComponentsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLanguageLevelComponentsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageSpec == nil {
				m.ImageSpec = &ImageSpec{}
			}
			if err := m.ImageSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LanguageLevelComponent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LanguageLevelComponent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LanguageLevelComponent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			m.SourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceType |= SourceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LanguageLevelComponents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LanguageLevelComponents: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LanguageLevelComponents: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Components = append(m.Components, &LanguageLevelComponent{})
			if err := m.Components[len(m.Components)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLanguageLevelComponentsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLanguageLevelComponentsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLanguageLevelComponentsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LayerToComponents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LayerToComponents == nil {
				m.LayerToComponents = make(map[string]*LanguageLevelComponents)
			}
			var mapkey string
			var mapvalue *LanguageLevelComponents
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImageScanService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImageScanService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthImageScanService
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthImageScanService
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImageScanService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthImageScanService
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthImageScanService
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &LanguageLevelComponents{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipImageScanService(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthImageScanService
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LayerToComponents[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetImageScanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImageScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetImageScanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetImageScanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ScanStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImageScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthImageScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &Image{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImageScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthImageScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImageScanService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImageScanService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImageScanService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthImageScanService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupImageScanService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthImageScanService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthImageScanService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImageScanService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupImageScanService = fmt.Errorf("proto: unexpected end of group")
)
