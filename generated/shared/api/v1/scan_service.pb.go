// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: shared/api/v1/scan_service.proto

package scannerV1

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SourceType int32

const (
	SourceType_UNSET_SOURCE_TYPE SourceType = 0
	SourceType_JAVA              SourceType = 1
	SourceType_PYTHON            SourceType = 2
	SourceType_NPM               SourceType = 3
	SourceType_GEM               SourceType = 4
	SourceType_DOTNETCORERUNTIME SourceType = 5
)

var SourceType_name = map[int32]string{
	0: "UNSET_SOURCE_TYPE",
	1: "JAVA",
	2: "PYTHON",
	3: "NPM",
	4: "GEM",
	5: "DOTNETCORERUNTIME",
}

var SourceType_value = map[string]int32{
	"UNSET_SOURCE_TYPE": 0,
	"JAVA":              1,
	"PYTHON":            2,
	"NPM":               3,
	"GEM":               4,
	"DOTNETCORERUNTIME": 5,
}

func (x SourceType) String() string {
	return proto.EnumName(SourceType_name, int32(x))
}

func (SourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{0}
}

type ScanStatus int32

const (
	ScanStatus_UNSET     ScanStatus = 0
	ScanStatus_ANALYZING ScanStatus = 1
	ScanStatus_FAILED    ScanStatus = 2
	ScanStatus_SUCCEEDED ScanStatus = 3
)

var ScanStatus_name = map[int32]string{
	0: "UNSET",
	1: "ANALYZING",
	2: "FAILED",
	3: "SUCCEEDED",
}

var ScanStatus_value = map[string]int32{
	"UNSET":     0,
	"ANALYZING": 1,
	"FAILED":    2,
	"SUCCEEDED": 3,
}

func (x ScanStatus) String() string {
	return proto.EnumName(ScanStatus_name, int32(x))
}

func (ScanStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{1}
}

type KubernetesComponent_KubernetesComponent int32

const (
	KubernetesComponent_UNSET                   KubernetesComponent_KubernetesComponent = 0
	KubernetesComponent_CLIENT_GO               KubernetesComponent_KubernetesComponent = 1
	KubernetesComponent_KUBE_AGGREGATOR         KubernetesComponent_KubernetesComponent = 2
	KubernetesComponent_KUBE_APISERVER          KubernetesComponent_KubernetesComponent = 3
	KubernetesComponent_KUBE_CONTROLLER_MANAGER KubernetesComponent_KubernetesComponent = 4
	KubernetesComponent_KUBE_DNS                KubernetesComponent_KubernetesComponent = 5
	KubernetesComponent_KUBE_PROXY              KubernetesComponent_KubernetesComponent = 6
	KubernetesComponent_KUBE_SCHEDULER          KubernetesComponent_KubernetesComponent = 7
	KubernetesComponent_KUBECTL                 KubernetesComponent_KubernetesComponent = 8
	KubernetesComponent_KUBELET                 KubernetesComponent_KubernetesComponent = 9
)

var KubernetesComponent_KubernetesComponent_name = map[int32]string{
	0: "UNSET",
	1: "CLIENT_GO",
	2: "KUBE_AGGREGATOR",
	3: "KUBE_APISERVER",
	4: "KUBE_CONTROLLER_MANAGER",
	5: "KUBE_DNS",
	6: "KUBE_PROXY",
	7: "KUBE_SCHEDULER",
	8: "KUBECTL",
	9: "KUBELET",
}

var KubernetesComponent_KubernetesComponent_value = map[string]int32{
	"UNSET":                   0,
	"CLIENT_GO":               1,
	"KUBE_AGGREGATOR":         2,
	"KUBE_APISERVER":          3,
	"KUBE_CONTROLLER_MANAGER": 4,
	"KUBE_DNS":                5,
	"KUBE_PROXY":              6,
	"KUBE_SCHEDULER":          7,
	"KUBECTL":                 8,
	"KUBELET":                 9,
}

func (x KubernetesComponent_KubernetesComponent) String() string {
	return proto.EnumName(KubernetesComponent_KubernetesComponent_name, int32(x))
}

func (KubernetesComponent_KubernetesComponent) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{17, 0}
}

type Image struct {
	Features             []*Feature `protobuf:"bytes,1,rep,name=features,proto3" json:"features,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Image) Reset()         { *m = Image{} }
func (m *Image) String() string { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()    {}
func (*Image) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{0}
}
func (m *Image) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Image) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Image.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Image) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Image.Merge(m, src)
}
func (m *Image) XXX_Size() int {
	return m.Size()
}
func (m *Image) XXX_DiscardUnknown() {
	xxx_messageInfo_Image.DiscardUnknown(m)
}

var xxx_messageInfo_Image proto.InternalMessageInfo

func (m *Image) GetFeatures() []*Feature {
	if m != nil {
		return m.Features
	}
	return nil
}

func (m *Image) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Image) Clone() *Image {
	if m == nil {
		return nil
	}
	cloned := new(Image)
	*cloned = *m

	if m.Features != nil {
		cloned.Features = make([]*Feature, len(m.Features))
		for idx, v := range m.Features {
			cloned.Features[idx] = v.Clone()
		}
	}
	return cloned
}

type Feature struct {
	Name                 string           `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Version              string           `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Vulnerabilities      []*Vulnerability `protobuf:"bytes,3,rep,name=vulnerabilities,proto3" json:"vulnerabilities,omitempty"`
	FeatureType          string           `protobuf:"bytes,4,opt,name=feature_type,json=featureType,proto3" json:"feature_type,omitempty"`
	AddedByLayer         string           `protobuf:"bytes,5,opt,name=added_by_layer,json=addedByLayer,proto3" json:"added_by_layer,omitempty"`
	Location             string           `protobuf:"bytes,6,opt,name=location,proto3" json:"location,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Feature) Reset()         { *m = Feature{} }
func (m *Feature) String() string { return proto.CompactTextString(m) }
func (*Feature) ProtoMessage()    {}
func (*Feature) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{1}
}
func (m *Feature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Feature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Feature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Feature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Feature.Merge(m, src)
}
func (m *Feature) XXX_Size() int {
	return m.Size()
}
func (m *Feature) XXX_DiscardUnknown() {
	xxx_messageInfo_Feature.DiscardUnknown(m)
}

var xxx_messageInfo_Feature proto.InternalMessageInfo

func (m *Feature) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Feature) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Feature) GetVulnerabilities() []*Vulnerability {
	if m != nil {
		return m.Vulnerabilities
	}
	return nil
}

func (m *Feature) GetFeatureType() string {
	if m != nil {
		return m.FeatureType
	}
	return ""
}

func (m *Feature) GetAddedByLayer() string {
	if m != nil {
		return m.AddedByLayer
	}
	return ""
}

func (m *Feature) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *Feature) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Feature) Clone() *Feature {
	if m == nil {
		return nil
	}
	cloned := new(Feature)
	*cloned = *m

	if m.Vulnerabilities != nil {
		cloned.Vulnerabilities = make([]*Vulnerability, len(m.Vulnerabilities))
		for idx, v := range m.Vulnerabilities {
			cloned.Vulnerabilities[idx] = v.Clone()
		}
	}
	return cloned
}

// Next tag: 7
type Vulnerability struct {
	Name                 string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description          string    `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Link                 string    `protobuf:"bytes,3,opt,name=link,proto3" json:"link,omitempty"`
	MetadataV2           *Metadata `protobuf:"bytes,6,opt,name=metadata_v2,json=metadataV2,proto3" json:"metadata_v2,omitempty"`
	FixedBy              string    `protobuf:"bytes,5,opt,name=fixed_by,json=fixedBy,proto3" json:"fixed_by,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Vulnerability) Reset()         { *m = Vulnerability{} }
func (m *Vulnerability) String() string { return proto.CompactTextString(m) }
func (*Vulnerability) ProtoMessage()    {}
func (*Vulnerability) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{2}
}
func (m *Vulnerability) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vulnerability) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vulnerability.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vulnerability) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vulnerability.Merge(m, src)
}
func (m *Vulnerability) XXX_Size() int {
	return m.Size()
}
func (m *Vulnerability) XXX_DiscardUnknown() {
	xxx_messageInfo_Vulnerability.DiscardUnknown(m)
}

var xxx_messageInfo_Vulnerability proto.InternalMessageInfo

func (m *Vulnerability) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Vulnerability) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Vulnerability) GetLink() string {
	if m != nil {
		return m.Link
	}
	return ""
}

func (m *Vulnerability) GetMetadataV2() *Metadata {
	if m != nil {
		return m.MetadataV2
	}
	return nil
}

func (m *Vulnerability) GetFixedBy() string {
	if m != nil {
		return m.FixedBy
	}
	return ""
}

func (m *Vulnerability) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Vulnerability) Clone() *Vulnerability {
	if m == nil {
		return nil
	}
	cloned := new(Vulnerability)
	*cloned = *m

	cloned.MetadataV2 = m.MetadataV2.Clone()
	return cloned
}

type Metadata struct {
	PublishedDateTime    string        `protobuf:"bytes,1,opt,name=published_date_time,json=publishedDateTime,proto3" json:"published_date_time,omitempty"`
	LastModifiedDateTime string        `protobuf:"bytes,2,opt,name=last_modified_date_time,json=lastModifiedDateTime,proto3" json:"last_modified_date_time,omitempty"`
	CvssV2               *CVSSMetadata `protobuf:"bytes,3,opt,name=cvss_v2,json=cvssV2,proto3" json:"cvss_v2,omitempty"`
	CvssV3               *CVSSMetadata `protobuf:"bytes,4,opt,name=cvss_v3,json=cvssV3,proto3" json:"cvss_v3,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{3}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetPublishedDateTime() string {
	if m != nil {
		return m.PublishedDateTime
	}
	return ""
}

func (m *Metadata) GetLastModifiedDateTime() string {
	if m != nil {
		return m.LastModifiedDateTime
	}
	return ""
}

func (m *Metadata) GetCvssV2() *CVSSMetadata {
	if m != nil {
		return m.CvssV2
	}
	return nil
}

func (m *Metadata) GetCvssV3() *CVSSMetadata {
	if m != nil {
		return m.CvssV3
	}
	return nil
}

func (m *Metadata) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Metadata) Clone() *Metadata {
	if m == nil {
		return nil
	}
	cloned := new(Metadata)
	*cloned = *m

	cloned.CvssV2 = m.CvssV2.Clone()
	cloned.CvssV3 = m.CvssV3.Clone()
	return cloned
}

type CVSSMetadata struct {
	Vector               string   `protobuf:"bytes,1,opt,name=vector,proto3" json:"vector,omitempty"`
	Score                float32  `protobuf:"fixed32,2,opt,name=score,proto3" json:"score,omitempty"`
	ExploitabilityScore  float32  `protobuf:"fixed32,3,opt,name=exploitability_score,json=exploitabilityScore,proto3" json:"exploitability_score,omitempty"`
	ImpactScore          float32  `protobuf:"fixed32,4,opt,name=impact_score,json=impactScore,proto3" json:"impact_score,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CVSSMetadata) Reset()         { *m = CVSSMetadata{} }
func (m *CVSSMetadata) String() string { return proto.CompactTextString(m) }
func (*CVSSMetadata) ProtoMessage()    {}
func (*CVSSMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{4}
}
func (m *CVSSMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CVSSMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CVSSMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CVSSMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CVSSMetadata.Merge(m, src)
}
func (m *CVSSMetadata) XXX_Size() int {
	return m.Size()
}
func (m *CVSSMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_CVSSMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_CVSSMetadata proto.InternalMessageInfo

func (m *CVSSMetadata) GetVector() string {
	if m != nil {
		return m.Vector
	}
	return ""
}

func (m *CVSSMetadata) GetScore() float32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *CVSSMetadata) GetExploitabilityScore() float32 {
	if m != nil {
		return m.ExploitabilityScore
	}
	return 0
}

func (m *CVSSMetadata) GetImpactScore() float32 {
	if m != nil {
		return m.ImpactScore
	}
	return 0
}

func (m *CVSSMetadata) MessageClone() proto.Message {
	return m.Clone()
}
func (m *CVSSMetadata) Clone() *CVSSMetadata {
	if m == nil {
		return nil
	}
	cloned := new(CVSSMetadata)
	*cloned = *m

	return cloned
}

type ScanImageRequest struct {
	Image                string                         `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	Registry             *ScanImageRequest_RegistryData `protobuf:"bytes,2,opt,name=registry,proto3" json:"registry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *ScanImageRequest) Reset()         { *m = ScanImageRequest{} }
func (m *ScanImageRequest) String() string { return proto.CompactTextString(m) }
func (*ScanImageRequest) ProtoMessage()    {}
func (*ScanImageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{5}
}
func (m *ScanImageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanImageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanImageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanImageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanImageRequest.Merge(m, src)
}
func (m *ScanImageRequest) XXX_Size() int {
	return m.Size()
}
func (m *ScanImageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanImageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ScanImageRequest proto.InternalMessageInfo

func (m *ScanImageRequest) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ScanImageRequest) GetRegistry() *ScanImageRequest_RegistryData {
	if m != nil {
		return m.Registry
	}
	return nil
}

func (m *ScanImageRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ScanImageRequest) Clone() *ScanImageRequest {
	if m == nil {
		return nil
	}
	cloned := new(ScanImageRequest)
	*cloned = *m

	cloned.Registry = m.Registry.Clone()
	return cloned
}

type ScanImageRequest_RegistryData struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Username             string   `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Insecure             bool     `protobuf:"varint,4,opt,name=insecure,proto3" json:"insecure,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ScanImageRequest_RegistryData) Reset()         { *m = ScanImageRequest_RegistryData{} }
func (m *ScanImageRequest_RegistryData) String() string { return proto.CompactTextString(m) }
func (*ScanImageRequest_RegistryData) ProtoMessage()    {}
func (*ScanImageRequest_RegistryData) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{5, 0}
}
func (m *ScanImageRequest_RegistryData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanImageRequest_RegistryData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanImageRequest_RegistryData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanImageRequest_RegistryData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanImageRequest_RegistryData.Merge(m, src)
}
func (m *ScanImageRequest_RegistryData) XXX_Size() int {
	return m.Size()
}
func (m *ScanImageRequest_RegistryData) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanImageRequest_RegistryData.DiscardUnknown(m)
}

var xxx_messageInfo_ScanImageRequest_RegistryData proto.InternalMessageInfo

func (m *ScanImageRequest_RegistryData) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ScanImageRequest_RegistryData) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *ScanImageRequest_RegistryData) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *ScanImageRequest_RegistryData) GetInsecure() bool {
	if m != nil {
		return m.Insecure
	}
	return false
}

func (m *ScanImageRequest_RegistryData) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ScanImageRequest_RegistryData) Clone() *ScanImageRequest_RegistryData {
	if m == nil {
		return nil
	}
	cloned := new(ScanImageRequest_RegistryData)
	*cloned = *m

	return cloned
}

type ScanImageResponse struct {
	Status               ScanStatus `protobuf:"varint,1,opt,name=status,proto3,enum=scannerV1.ScanStatus" json:"status,omitempty"`
	Image                *ImageSpec `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ScanImageResponse) Reset()         { *m = ScanImageResponse{} }
func (m *ScanImageResponse) String() string { return proto.CompactTextString(m) }
func (*ScanImageResponse) ProtoMessage()    {}
func (*ScanImageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{6}
}
func (m *ScanImageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScanImageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScanImageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScanImageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScanImageResponse.Merge(m, src)
}
func (m *ScanImageResponse) XXX_Size() int {
	return m.Size()
}
func (m *ScanImageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ScanImageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ScanImageResponse proto.InternalMessageInfo

func (m *ScanImageResponse) GetStatus() ScanStatus {
	if m != nil {
		return m.Status
	}
	return ScanStatus_UNSET
}

func (m *ScanImageResponse) GetImage() *ImageSpec {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *ScanImageResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ScanImageResponse) Clone() *ScanImageResponse {
	if m == nil {
		return nil
	}
	cloned := new(ScanImageResponse)
	*cloned = *m

	cloned.Image = m.Image.Clone()
	return cloned
}

type ImageSpec struct {
	Digest               string   `protobuf:"bytes,1,opt,name=digest,proto3" json:"digest,omitempty"`
	Image                string   `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageSpec) Reset()         { *m = ImageSpec{} }
func (m *ImageSpec) String() string { return proto.CompactTextString(m) }
func (*ImageSpec) ProtoMessage()    {}
func (*ImageSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{7}
}
func (m *ImageSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImageSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImageSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImageSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageSpec.Merge(m, src)
}
func (m *ImageSpec) XXX_Size() int {
	return m.Size()
}
func (m *ImageSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ImageSpec proto.InternalMessageInfo

func (m *ImageSpec) GetDigest() string {
	if m != nil {
		return m.Digest
	}
	return ""
}

func (m *ImageSpec) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ImageSpec) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ImageSpec) Clone() *ImageSpec {
	if m == nil {
		return nil
	}
	cloned := new(ImageSpec)
	*cloned = *m

	return cloned
}

type GetScanRequest struct {
	// Only one of the fields in ImageSpec needs to be set for the request to be properly formed
	// If both are set, then digest is used
	ImageSpec            *ImageSpec `protobuf:"bytes,1,opt,name=image_spec,json=imageSpec,proto3" json:"image_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetScanRequest) Reset()         { *m = GetScanRequest{} }
func (m *GetScanRequest) String() string { return proto.CompactTextString(m) }
func (*GetScanRequest) ProtoMessage()    {}
func (*GetScanRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{8}
}
func (m *GetScanRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetScanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetScanRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetScanRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetScanRequest.Merge(m, src)
}
func (m *GetScanRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetScanRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetScanRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetScanRequest proto.InternalMessageInfo

func (m *GetScanRequest) GetImageSpec() *ImageSpec {
	if m != nil {
		return m.ImageSpec
	}
	return nil
}

func (m *GetScanRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetScanRequest) Clone() *GetScanRequest {
	if m == nil {
		return nil
	}
	cloned := new(GetScanRequest)
	*cloned = *m

	cloned.ImageSpec = m.ImageSpec.Clone()
	return cloned
}

type GetLanguageLevelComponentsRequest struct {
	// Only one of the fields in ImageSpec needs to be set for the request to be properly formed
	// If both are set, then digest is used
	ImageSpec            *ImageSpec `protobuf:"bytes,1,opt,name=image_spec,json=imageSpec,proto3" json:"image_spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetLanguageLevelComponentsRequest) Reset()         { *m = GetLanguageLevelComponentsRequest{} }
func (m *GetLanguageLevelComponentsRequest) String() string { return proto.CompactTextString(m) }
func (*GetLanguageLevelComponentsRequest) ProtoMessage()    {}
func (*GetLanguageLevelComponentsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{9}
}
func (m *GetLanguageLevelComponentsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLanguageLevelComponentsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLanguageLevelComponentsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLanguageLevelComponentsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLanguageLevelComponentsRequest.Merge(m, src)
}
func (m *GetLanguageLevelComponentsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLanguageLevelComponentsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLanguageLevelComponentsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLanguageLevelComponentsRequest proto.InternalMessageInfo

func (m *GetLanguageLevelComponentsRequest) GetImageSpec() *ImageSpec {
	if m != nil {
		return m.ImageSpec
	}
	return nil
}

func (m *GetLanguageLevelComponentsRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetLanguageLevelComponentsRequest) Clone() *GetLanguageLevelComponentsRequest {
	if m == nil {
		return nil
	}
	cloned := new(GetLanguageLevelComponentsRequest)
	*cloned = *m

	cloned.ImageSpec = m.ImageSpec.Clone()
	return cloned
}

type LanguageLevelComponent struct {
	SourceType           SourceType `protobuf:"varint,1,opt,name=source_type,json=sourceType,proto3,enum=scannerV1.SourceType" json:"source_type,omitempty"`
	Name                 string     `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Version              string     `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	Location             string     `protobuf:"bytes,4,opt,name=location,proto3" json:"location,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *LanguageLevelComponent) Reset()         { *m = LanguageLevelComponent{} }
func (m *LanguageLevelComponent) String() string { return proto.CompactTextString(m) }
func (*LanguageLevelComponent) ProtoMessage()    {}
func (*LanguageLevelComponent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{10}
}
func (m *LanguageLevelComponent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LanguageLevelComponent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LanguageLevelComponent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LanguageLevelComponent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LanguageLevelComponent.Merge(m, src)
}
func (m *LanguageLevelComponent) XXX_Size() int {
	return m.Size()
}
func (m *LanguageLevelComponent) XXX_DiscardUnknown() {
	xxx_messageInfo_LanguageLevelComponent.DiscardUnknown(m)
}

var xxx_messageInfo_LanguageLevelComponent proto.InternalMessageInfo

func (m *LanguageLevelComponent) GetSourceType() SourceType {
	if m != nil {
		return m.SourceType
	}
	return SourceType_UNSET_SOURCE_TYPE
}

func (m *LanguageLevelComponent) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LanguageLevelComponent) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *LanguageLevelComponent) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *LanguageLevelComponent) MessageClone() proto.Message {
	return m.Clone()
}
func (m *LanguageLevelComponent) Clone() *LanguageLevelComponent {
	if m == nil {
		return nil
	}
	cloned := new(LanguageLevelComponent)
	*cloned = *m

	return cloned
}

type LanguageLevelComponents struct {
	Components           []*LanguageLevelComponent `protobuf:"bytes,1,rep,name=components,proto3" json:"components,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *LanguageLevelComponents) Reset()         { *m = LanguageLevelComponents{} }
func (m *LanguageLevelComponents) String() string { return proto.CompactTextString(m) }
func (*LanguageLevelComponents) ProtoMessage()    {}
func (*LanguageLevelComponents) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{11}
}
func (m *LanguageLevelComponents) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LanguageLevelComponents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LanguageLevelComponents.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LanguageLevelComponents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LanguageLevelComponents.Merge(m, src)
}
func (m *LanguageLevelComponents) XXX_Size() int {
	return m.Size()
}
func (m *LanguageLevelComponents) XXX_DiscardUnknown() {
	xxx_messageInfo_LanguageLevelComponents.DiscardUnknown(m)
}

var xxx_messageInfo_LanguageLevelComponents proto.InternalMessageInfo

func (m *LanguageLevelComponents) GetComponents() []*LanguageLevelComponent {
	if m != nil {
		return m.Components
	}
	return nil
}

func (m *LanguageLevelComponents) MessageClone() proto.Message {
	return m.Clone()
}
func (m *LanguageLevelComponents) Clone() *LanguageLevelComponents {
	if m == nil {
		return nil
	}
	cloned := new(LanguageLevelComponents)
	*cloned = *m

	if m.Components != nil {
		cloned.Components = make([]*LanguageLevelComponent, len(m.Components))
		for idx, v := range m.Components {
			cloned.Components[idx] = v.Clone()
		}
	}
	return cloned
}

type GetLanguageLevelComponentsResponse struct {
	LayerToComponents    map[string]*LanguageLevelComponents `protobuf:"bytes,1,rep,name=layer_to_components,json=layerToComponents,proto3" json:"layer_to_components,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *GetLanguageLevelComponentsResponse) Reset()         { *m = GetLanguageLevelComponentsResponse{} }
func (m *GetLanguageLevelComponentsResponse) String() string { return proto.CompactTextString(m) }
func (*GetLanguageLevelComponentsResponse) ProtoMessage()    {}
func (*GetLanguageLevelComponentsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{12}
}
func (m *GetLanguageLevelComponentsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLanguageLevelComponentsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLanguageLevelComponentsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLanguageLevelComponentsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLanguageLevelComponentsResponse.Merge(m, src)
}
func (m *GetLanguageLevelComponentsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetLanguageLevelComponentsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLanguageLevelComponentsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLanguageLevelComponentsResponse proto.InternalMessageInfo

func (m *GetLanguageLevelComponentsResponse) GetLayerToComponents() map[string]*LanguageLevelComponents {
	if m != nil {
		return m.LayerToComponents
	}
	return nil
}

func (m *GetLanguageLevelComponentsResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetLanguageLevelComponentsResponse) Clone() *GetLanguageLevelComponentsResponse {
	if m == nil {
		return nil
	}
	cloned := new(GetLanguageLevelComponentsResponse)
	*cloned = *m

	if m.LayerToComponents != nil {
		cloned.LayerToComponents = make(map[string]*LanguageLevelComponents, len(m.LayerToComponents))
		for k, v := range m.LayerToComponents {
			cloned.LayerToComponents[k] = v.Clone()
		}
	}
	return cloned
}

type GetScanResponse struct {
	Status               ScanStatus `protobuf:"varint,1,opt,name=status,proto3,enum=scannerV1.ScanStatus" json:"status,omitempty"`
	Image                *Image     `protobuf:"bytes,2,opt,name=image,proto3" json:"image,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetScanResponse) Reset()         { *m = GetScanResponse{} }
func (m *GetScanResponse) String() string { return proto.CompactTextString(m) }
func (*GetScanResponse) ProtoMessage()    {}
func (*GetScanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{13}
}
func (m *GetScanResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetScanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetScanResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetScanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetScanResponse.Merge(m, src)
}
func (m *GetScanResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetScanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetScanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetScanResponse proto.InternalMessageInfo

func (m *GetScanResponse) GetStatus() ScanStatus {
	if m != nil {
		return m.Status
	}
	return ScanStatus_UNSET
}

func (m *GetScanResponse) GetImage() *Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *GetScanResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetScanResponse) Clone() *GetScanResponse {
	if m == nil {
		return nil
	}
	cloned := new(GetScanResponse)
	*cloned = *m

	cloned.Image = m.Image.Clone()
	return cloned
}

type GetVulnerabilitiesRequest struct {
	Components           []*Component `protobuf:"bytes,1,rep,name=components,proto3" json:"components,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *GetVulnerabilitiesRequest) Reset()         { *m = GetVulnerabilitiesRequest{} }
func (m *GetVulnerabilitiesRequest) String() string { return proto.CompactTextString(m) }
func (*GetVulnerabilitiesRequest) ProtoMessage()    {}
func (*GetVulnerabilitiesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{14}
}
func (m *GetVulnerabilitiesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVulnerabilitiesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVulnerabilitiesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetVulnerabilitiesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVulnerabilitiesRequest.Merge(m, src)
}
func (m *GetVulnerabilitiesRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetVulnerabilitiesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVulnerabilitiesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetVulnerabilitiesRequest proto.InternalMessageInfo

func (m *GetVulnerabilitiesRequest) GetComponents() []*Component {
	if m != nil {
		return m.Components
	}
	return nil
}

func (m *GetVulnerabilitiesRequest) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetVulnerabilitiesRequest) Clone() *GetVulnerabilitiesRequest {
	if m == nil {
		return nil
	}
	cloned := new(GetVulnerabilitiesRequest)
	*cloned = *m

	if m.Components != nil {
		cloned.Components = make([]*Component, len(m.Components))
		for idx, v := range m.Components {
			cloned.Components[idx] = v.Clone()
		}
	}
	return cloned
}

type Component struct {
	// Types that are valid to be assigned to Component:
	//	*Component_AppComponent
	//	*Component_K8SComponent
	Component            isComponent_Component `protobuf_oneof:"component"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Component) Reset()         { *m = Component{} }
func (m *Component) String() string { return proto.CompactTextString(m) }
func (*Component) ProtoMessage()    {}
func (*Component) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{15}
}
func (m *Component) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Component) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Component.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Component) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Component.Merge(m, src)
}
func (m *Component) XXX_Size() int {
	return m.Size()
}
func (m *Component) XXX_DiscardUnknown() {
	xxx_messageInfo_Component.DiscardUnknown(m)
}

var xxx_messageInfo_Component proto.InternalMessageInfo

type isComponent_Component interface {
	isComponent_Component()
	MarshalTo([]byte) (int, error)
	Size() int
	Clone() isComponent_Component
}

type Component_AppComponent struct {
	AppComponent *ApplicationComponent `protobuf:"bytes,1,opt,name=app_component,json=appComponent,proto3,oneof" json:"app_component,omitempty"`
}
type Component_K8SComponent struct {
	K8SComponent *KubernetesComponent `protobuf:"bytes,2,opt,name=k8s_component,json=k8sComponent,proto3,oneof" json:"k8s_component,omitempty"`
}

func (*Component_AppComponent) isComponent_Component() {}
func (m *Component_AppComponent) Clone() isComponent_Component {
	if m == nil {
		return nil
	}
	cloned := new(Component_AppComponent)
	*cloned = *m

	cloned.AppComponent = m.AppComponent.Clone()
	return cloned
}
func (*Component_K8SComponent) isComponent_Component() {}
func (m *Component_K8SComponent) Clone() isComponent_Component {
	if m == nil {
		return nil
	}
	cloned := new(Component_K8SComponent)
	*cloned = *m

	cloned.K8SComponent = m.K8SComponent.Clone()
	return cloned
}

func (m *Component) GetComponent() isComponent_Component {
	if m != nil {
		return m.Component
	}
	return nil
}

func (m *Component) GetAppComponent() *ApplicationComponent {
	if x, ok := m.GetComponent().(*Component_AppComponent); ok {
		return x.AppComponent
	}
	return nil
}

func (m *Component) GetK8SComponent() *KubernetesComponent {
	if x, ok := m.GetComponent().(*Component_K8SComponent); ok {
		return x.K8SComponent
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Component) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Component_AppComponent)(nil),
		(*Component_K8SComponent)(nil),
	}
}

func (m *Component) MessageClone() proto.Message {
	return m.Clone()
}
func (m *Component) Clone() *Component {
	if m == nil {
		return nil
	}
	cloned := new(Component)
	*cloned = *m

	if m.Component != nil {
		cloned.Component = m.Component.Clone()
	}
	return cloned
}

type ApplicationComponent struct {
	Vendor               string   `protobuf:"bytes,1,opt,name=vendor,proto3" json:"vendor,omitempty"`
	Product              string   `protobuf:"bytes,2,opt,name=product,proto3" json:"product,omitempty"`
	Version              string   `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ApplicationComponent) Reset()         { *m = ApplicationComponent{} }
func (m *ApplicationComponent) String() string { return proto.CompactTextString(m) }
func (*ApplicationComponent) ProtoMessage()    {}
func (*ApplicationComponent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{16}
}
func (m *ApplicationComponent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApplicationComponent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApplicationComponent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApplicationComponent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApplicationComponent.Merge(m, src)
}
func (m *ApplicationComponent) XXX_Size() int {
	return m.Size()
}
func (m *ApplicationComponent) XXX_DiscardUnknown() {
	xxx_messageInfo_ApplicationComponent.DiscardUnknown(m)
}

var xxx_messageInfo_ApplicationComponent proto.InternalMessageInfo

func (m *ApplicationComponent) GetVendor() string {
	if m != nil {
		return m.Vendor
	}
	return ""
}

func (m *ApplicationComponent) GetProduct() string {
	if m != nil {
		return m.Product
	}
	return ""
}

func (m *ApplicationComponent) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ApplicationComponent) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ApplicationComponent) Clone() *ApplicationComponent {
	if m == nil {
		return nil
	}
	cloned := new(ApplicationComponent)
	*cloned = *m

	return cloned
}

type KubernetesComponent struct {
	Component            KubernetesComponent_KubernetesComponent `protobuf:"varint,1,opt,name=component,proto3,enum=scannerV1.KubernetesComponent_KubernetesComponent" json:"component,omitempty"`
	Version              string                                  `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                `json:"-"`
	XXX_unrecognized     []byte                                  `json:"-"`
	XXX_sizecache        int32                                   `json:"-"`
}

func (m *KubernetesComponent) Reset()         { *m = KubernetesComponent{} }
func (m *KubernetesComponent) String() string { return proto.CompactTextString(m) }
func (*KubernetesComponent) ProtoMessage()    {}
func (*KubernetesComponent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{17}
}
func (m *KubernetesComponent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesComponent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesComponent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesComponent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesComponent.Merge(m, src)
}
func (m *KubernetesComponent) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesComponent) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesComponent.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesComponent proto.InternalMessageInfo

func (m *KubernetesComponent) GetComponent() KubernetesComponent_KubernetesComponent {
	if m != nil {
		return m.Component
	}
	return KubernetesComponent_UNSET
}

func (m *KubernetesComponent) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *KubernetesComponent) MessageClone() proto.Message {
	return m.Clone()
}
func (m *KubernetesComponent) Clone() *KubernetesComponent {
	if m == nil {
		return nil
	}
	cloned := new(KubernetesComponent)
	*cloned = *m

	return cloned
}

type GetVulnerabilitiesResponse struct {
	VulnerabilitiesByComponent []*ComponentWithVulns `protobuf:"bytes,1,rep,name=vulnerabilities_by_component,json=vulnerabilitiesByComponent,proto3" json:"vulnerabilities_by_component,omitempty"`
	XXX_NoUnkeyedLiteral       struct{}              `json:"-"`
	XXX_unrecognized           []byte                `json:"-"`
	XXX_sizecache              int32                 `json:"-"`
}

func (m *GetVulnerabilitiesResponse) Reset()         { *m = GetVulnerabilitiesResponse{} }
func (m *GetVulnerabilitiesResponse) String() string { return proto.CompactTextString(m) }
func (*GetVulnerabilitiesResponse) ProtoMessage()    {}
func (*GetVulnerabilitiesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{18}
}
func (m *GetVulnerabilitiesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetVulnerabilitiesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetVulnerabilitiesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetVulnerabilitiesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVulnerabilitiesResponse.Merge(m, src)
}
func (m *GetVulnerabilitiesResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetVulnerabilitiesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVulnerabilitiesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetVulnerabilitiesResponse proto.InternalMessageInfo

func (m *GetVulnerabilitiesResponse) GetVulnerabilitiesByComponent() []*ComponentWithVulns {
	if m != nil {
		return m.VulnerabilitiesByComponent
	}
	return nil
}

func (m *GetVulnerabilitiesResponse) MessageClone() proto.Message {
	return m.Clone()
}
func (m *GetVulnerabilitiesResponse) Clone() *GetVulnerabilitiesResponse {
	if m == nil {
		return nil
	}
	cloned := new(GetVulnerabilitiesResponse)
	*cloned = *m

	if m.VulnerabilitiesByComponent != nil {
		cloned.VulnerabilitiesByComponent = make([]*ComponentWithVulns, len(m.VulnerabilitiesByComponent))
		for idx, v := range m.VulnerabilitiesByComponent {
			cloned.VulnerabilitiesByComponent[idx] = v.Clone()
		}
	}
	return cloned
}

type ComponentWithVulns struct {
	Component            *Component       `protobuf:"bytes,1,opt,name=component,proto3" json:"component,omitempty"`
	Vulnerabilities      []*Vulnerability `protobuf:"bytes,2,rep,name=vulnerabilities,proto3" json:"vulnerabilities,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ComponentWithVulns) Reset()         { *m = ComponentWithVulns{} }
func (m *ComponentWithVulns) String() string { return proto.CompactTextString(m) }
func (*ComponentWithVulns) ProtoMessage()    {}
func (*ComponentWithVulns) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ae66a2889f8d924, []int{19}
}
func (m *ComponentWithVulns) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComponentWithVulns) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComponentWithVulns.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComponentWithVulns) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComponentWithVulns.Merge(m, src)
}
func (m *ComponentWithVulns) XXX_Size() int {
	return m.Size()
}
func (m *ComponentWithVulns) XXX_DiscardUnknown() {
	xxx_messageInfo_ComponentWithVulns.DiscardUnknown(m)
}

var xxx_messageInfo_ComponentWithVulns proto.InternalMessageInfo

func (m *ComponentWithVulns) GetComponent() *Component {
	if m != nil {
		return m.Component
	}
	return nil
}

func (m *ComponentWithVulns) GetVulnerabilities() []*Vulnerability {
	if m != nil {
		return m.Vulnerabilities
	}
	return nil
}

func (m *ComponentWithVulns) MessageClone() proto.Message {
	return m.Clone()
}
func (m *ComponentWithVulns) Clone() *ComponentWithVulns {
	if m == nil {
		return nil
	}
	cloned := new(ComponentWithVulns)
	*cloned = *m

	cloned.Component = m.Component.Clone()
	if m.Vulnerabilities != nil {
		cloned.Vulnerabilities = make([]*Vulnerability, len(m.Vulnerabilities))
		for idx, v := range m.Vulnerabilities {
			cloned.Vulnerabilities[idx] = v.Clone()
		}
	}
	return cloned
}

func init() {
	proto.RegisterEnum("scannerV1.SourceType", SourceType_name, SourceType_value)
	proto.RegisterEnum("scannerV1.ScanStatus", ScanStatus_name, ScanStatus_value)
	proto.RegisterEnum("scannerV1.KubernetesComponent_KubernetesComponent", KubernetesComponent_KubernetesComponent_name, KubernetesComponent_KubernetesComponent_value)
	proto.RegisterType((*Image)(nil), "scannerV1.Image")
	proto.RegisterType((*Feature)(nil), "scannerV1.Feature")
	proto.RegisterType((*Vulnerability)(nil), "scannerV1.Vulnerability")
	proto.RegisterType((*Metadata)(nil), "scannerV1.Metadata")
	proto.RegisterType((*CVSSMetadata)(nil), "scannerV1.CVSSMetadata")
	proto.RegisterType((*ScanImageRequest)(nil), "scannerV1.ScanImageRequest")
	proto.RegisterType((*ScanImageRequest_RegistryData)(nil), "scannerV1.ScanImageRequest.RegistryData")
	proto.RegisterType((*ScanImageResponse)(nil), "scannerV1.ScanImageResponse")
	proto.RegisterType((*ImageSpec)(nil), "scannerV1.ImageSpec")
	proto.RegisterType((*GetScanRequest)(nil), "scannerV1.GetScanRequest")
	proto.RegisterType((*GetLanguageLevelComponentsRequest)(nil), "scannerV1.GetLanguageLevelComponentsRequest")
	proto.RegisterType((*LanguageLevelComponent)(nil), "scannerV1.LanguageLevelComponent")
	proto.RegisterType((*LanguageLevelComponents)(nil), "scannerV1.LanguageLevelComponents")
	proto.RegisterType((*GetLanguageLevelComponentsResponse)(nil), "scannerV1.GetLanguageLevelComponentsResponse")
	proto.RegisterMapType((map[string]*LanguageLevelComponents)(nil), "scannerV1.GetLanguageLevelComponentsResponse.LayerToComponentsEntry")
	proto.RegisterType((*GetScanResponse)(nil), "scannerV1.GetScanResponse")
	proto.RegisterType((*GetVulnerabilitiesRequest)(nil), "scannerV1.GetVulnerabilitiesRequest")
	proto.RegisterType((*Component)(nil), "scannerV1.Component")
	proto.RegisterType((*ApplicationComponent)(nil), "scannerV1.ApplicationComponent")
	proto.RegisterType((*KubernetesComponent)(nil), "scannerV1.KubernetesComponent")
	proto.RegisterType((*GetVulnerabilitiesResponse)(nil), "scannerV1.GetVulnerabilitiesResponse")
	proto.RegisterType((*ComponentWithVulns)(nil), "scannerV1.ComponentWithVulns")
}

func init() { proto.RegisterFile("shared/api/v1/scan_service.proto", fileDescriptor_6ae66a2889f8d924) }

var fileDescriptor_6ae66a2889f8d924 = []byte{
	// 1511 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0x4b, 0x6f, 0xdb, 0xc6,
	0x16, 0x36, 0xf5, 0xb0, 0xa4, 0x23, 0x3f, 0xe8, 0xb1, 0x13, 0x2b, 0x8a, 0xe3, 0xd8, 0x44, 0x72,
	0x11, 0x18, 0x37, 0xca, 0xb5, 0x9c, 0x7b, 0xaf, 0x1b, 0xa0, 0x0b, 0x59, 0x62, 0x14, 0x27, 0xb2,
	0xe4, 0x52, 0xb2, 0x1a, 0x07, 0x05, 0x08, 0x8a, 0x9a, 0xd8, 0x84, 0x69, 0x92, 0xe5, 0x8c, 0xd4,
	0x68, 0xd1, 0x4d, 0xd1, 0xee, 0xba, 0x6a, 0x37, 0x45, 0x57, 0xdd, 0x75, 0xdb, 0xbf, 0xd0, 0x45,
	0x81, 0x2e, 0x0b, 0x14, 0xdd, 0x07, 0x69, 0xfe, 0x43, 0xb7, 0xc5, 0x0c, 0x1f, 0xa2, 0x14, 0x3a,
	0x6e, 0xda, 0x1d, 0xcf, 0xeb, 0x3b, 0xe7, 0xcc, 0x79, 0xcc, 0x10, 0x36, 0xc8, 0xa9, 0xe6, 0xe2,
	0xfe, 0x3d, 0xcd, 0x31, 0xee, 0x0d, 0xb7, 0xef, 0x11, 0x5d, 0xb3, 0x54, 0x82, 0xdd, 0xa1, 0xa1,
	0xe3, 0x92, 0xe3, 0xda, 0xd4, 0x46, 0x39, 0xc6, 0xb3, 0xb0, 0xdb, 0xdd, 0x2e, 0xae, 0x9d, 0xd8,
	0xf6, 0x89, 0x89, 0xb9, 0xb2, 0x66, 0x59, 0x36, 0xd5, 0xa8, 0x61, 0x5b, 0xc4, 0x53, 0x94, 0xfe,
	0x0f, 0xe9, 0xfd, 0x73, 0xed, 0x04, 0xa3, 0x12, 0x64, 0x9f, 0x63, 0x8d, 0x0e, 0x5c, 0x4c, 0x0a,
	0xc2, 0x46, 0xf2, 0x4e, 0xbe, 0x8c, 0x4a, 0x21, 0x48, 0xe9, 0xa1, 0x27, 0x52, 0x42, 0x1d, 0xe9,
	0xa5, 0x00, 0x19, 0x9f, 0x8b, 0x10, 0xa4, 0x2c, 0xed, 0x1c, 0x17, 0x84, 0x0d, 0xe1, 0x4e, 0x4e,
	0xe1, 0xdf, 0xa8, 0x00, 0x99, 0x21, 0x76, 0x89, 0x61, 0x5b, 0x85, 0x04, 0x67, 0x07, 0x24, 0xda,
	0x83, 0xc5, 0xe1, 0xc0, 0xb4, 0xb0, 0xab, 0xf5, 0x0c, 0xd3, 0xa0, 0x06, 0x26, 0x85, 0x24, 0x77,
	0x58, 0x88, 0x38, 0xec, 0x46, 0x34, 0x46, 0xca, 0xb4, 0x01, 0xda, 0x84, 0x39, 0x3f, 0x12, 0x95,
	0x8e, 0x1c, 0x5c, 0x48, 0x71, 0x17, 0x79, 0x9f, 0xd7, 0x19, 0x39, 0x18, 0xdd, 0x82, 0x05, 0xad,
	0xdf, 0xc7, 0x7d, 0xb5, 0x37, 0x52, 0x4d, 0x6d, 0x84, 0xdd, 0x42, 0x9a, 0x2b, 0xcd, 0x71, 0xee,
	0xde, 0xa8, 0xc1, 0x78, 0xa8, 0x08, 0x59, 0xd3, 0xd6, 0xf9, 0x91, 0x14, 0x66, 0xb9, 0x3c, 0xa4,
	0xa5, 0x1f, 0x04, 0x98, 0x9f, 0x88, 0x23, 0x36, 0xd1, 0x0d, 0xc8, 0xf7, 0x31, 0xd1, 0x5d, 0xc3,
	0xa1, 0xe3, 0x64, 0xa3, 0x2c, 0x66, 0x65, 0x1a, 0xd6, 0x59, 0x21, 0xe9, 0x59, 0xb1, 0x6f, 0x74,
	0x1f, 0xf2, 0xe7, 0x98, 0x6a, 0x7d, 0x8d, 0x6a, 0xea, 0xb0, 0xcc, 0x5d, 0xe7, 0xcb, 0xcb, 0x91,
	0x03, 0x38, 0xf0, 0xa5, 0x0a, 0x04, 0x7a, 0xdd, 0x32, 0xba, 0x06, 0xd9, 0xe7, 0xc6, 0x0b, 0x9e,
	0x93, 0x9f, 0x4d, 0x86, 0xd3, 0x7b, 0xa3, 0xc7, 0xa9, 0x6c, 0x4a, 0x4c, 0x4b, 0xbf, 0x09, 0x90,
	0x0d, 0x2c, 0x51, 0x09, 0x96, 0x9d, 0x41, 0xcf, 0x34, 0xc8, 0x29, 0xee, 0xab, 0x7d, 0x8d, 0x62,
	0x95, 0x1a, 0x61, 0xf0, 0x4b, 0xa1, 0xa8, 0xa6, 0x51, 0xdc, 0x31, 0xce, 0x31, 0xfa, 0x2f, 0xac,
	0x9a, 0x1a, 0xa1, 0xea, 0xb9, 0xdd, 0x37, 0x9e, 0x1b, 0x13, 0x36, 0x5e, 0x56, 0x2b, 0x4c, 0x7c,
	0xe0, 0x4b, 0x43, 0xb3, 0xff, 0x40, 0x46, 0x1f, 0x12, 0xc2, 0xd2, 0x48, 0xf2, 0x34, 0x56, 0x23,
	0x69, 0x54, 0xbb, 0xed, 0x76, 0x98, 0xca, 0x2c, 0xd3, 0xeb, 0x96, 0xc7, 0x16, 0x3b, 0xbc, 0x70,
	0x97, 0x5a, 0xec, 0x48, 0x5f, 0x09, 0x30, 0x17, 0x15, 0xa0, 0xab, 0x30, 0x3b, 0xc4, 0x3a, 0xb5,
	0x5d, 0x3f, 0x1d, 0x9f, 0x42, 0x2b, 0x90, 0x26, 0xba, 0xed, 0x7a, 0x11, 0x27, 0x14, 0x8f, 0x40,
	0xdb, 0xb0, 0x82, 0x5f, 0x38, 0xa6, 0x6d, 0x50, 0xbf, 0x92, 0xaa, 0xa7, 0x94, 0xe4, 0x4a, 0xcb,
	0x93, 0xb2, 0x36, 0x37, 0xd9, 0x84, 0x39, 0xe3, 0xdc, 0xd1, 0x74, 0xea, 0xab, 0xa6, 0xb8, 0x6a,
	0xde, 0xe3, 0x71, 0x15, 0xe9, 0xb5, 0x00, 0x62, 0x5b, 0xd7, 0x2c, 0x3e, 0x40, 0x0a, 0xfe, 0x78,
	0x80, 0x09, 0x65, 0x01, 0x18, 0x8c, 0xf6, 0xe3, 0xf2, 0x08, 0x54, 0x83, 0xac, 0x8b, 0x4f, 0x0c,
	0x42, 0xdd, 0x11, 0x8f, 0x2c, 0x5f, 0xbe, 0x13, 0x49, 0x79, 0x1a, 0xa4, 0xa4, 0xf8, 0xba, 0x35,
	0x76, 0x06, 0xa1, 0x65, 0x91, 0xc2, 0x5c, 0x54, 0x82, 0x44, 0x48, 0x0e, 0x5c, 0xd3, 0xf7, 0xc4,
	0x3e, 0x59, 0x3b, 0x0f, 0x08, 0x76, 0x79, 0x93, 0x7a, 0x35, 0x0b, 0x69, 0x26, 0x73, 0x34, 0x42,
	0x3e, 0xb1, 0xdd, 0xbe, 0xdf, 0x8a, 0x21, 0xcd, 0x64, 0x86, 0x45, 0xb0, 0x3e, 0xf0, 0x33, 0xcd,
	0x2a, 0x21, 0x2d, 0x59, 0xb0, 0x14, 0x09, 0x90, 0x38, 0xb6, 0x45, 0x30, 0xba, 0x0b, 0xb3, 0x84,
	0x6a, 0x74, 0x40, 0xb8, 0xf7, 0x85, 0xf2, 0x95, 0xa9, 0x74, 0xda, 0x5c, 0xa8, 0xf8, 0x4a, 0x68,
	0x2b, 0x38, 0x15, 0x2f, 0xf9, 0x95, 0x88, 0x36, 0xc7, 0x6d, 0x3b, 0x58, 0xf7, 0xcf, 0x4a, 0x7a,
	0x0f, 0x72, 0x21, 0x8f, 0xd5, 0xb9, 0x6f, 0x9c, 0x60, 0x42, 0x83, 0x3a, 0x7b, 0xd4, 0xf8, 0x98,
	0x13, 0x91, 0x63, 0x96, 0x64, 0x58, 0xa8, 0x63, 0xca, 0xfc, 0x07, 0xe5, 0xd8, 0x01, 0xe0, 0x22,
	0x95, 0x38, 0x58, 0xe7, 0x18, 0x17, 0x79, 0xcf, 0x19, 0xc1, 0xa7, 0xf4, 0x14, 0x36, 0xeb, 0x98,
	0x36, 0x34, 0xeb, 0x64, 0xa0, 0x9d, 0xe0, 0x06, 0x1e, 0x62, 0xb3, 0x6a, 0x9f, 0x3b, 0xb6, 0x85,
	0x2d, 0x4a, 0xfe, 0x11, 0xf2, 0xb7, 0x02, 0x5c, 0x8d, 0xc7, 0x45, 0xff, 0x83, 0x3c, 0xb1, 0x07,
	0xae, 0xee, 0x6f, 0xb4, 0x98, 0x63, 0xe5, 0x52, 0xb6, 0xdb, 0x14, 0x20, 0xe1, 0x77, 0xb8, 0x93,
	0x12, 0xf1, 0xcb, 0x37, 0x39, 0xb9, 0x7c, 0xa3, 0xfb, 0x2e, 0x35, 0xb5, 0xef, 0x3e, 0x82, 0xd5,
	0x0b, 0x72, 0x46, 0x15, 0x00, 0x3d, 0xa4, 0xfc, 0xfb, 0x61, 0x33, 0x12, 0x5b, 0xbc, 0x9d, 0x12,
	0x31, 0x92, 0x3e, 0x4f, 0x80, 0xf4, 0xb6, 0x53, 0xf5, 0x1b, 0x8b, 0xc2, 0x32, 0xdf, 0xd6, 0x2a,
	0xb5, 0xd5, 0x37, 0x5c, 0xd6, 0x22, 0x2e, 0x2f, 0xc7, 0x2a, 0xf1, 0x15, 0xdf, 0xb1, 0xc7, 0x12,
	0xd9, 0xa2, 0xee, 0x48, 0x59, 0x32, 0xa7, 0xf9, 0xc5, 0x53, 0x56, 0x96, 0x38, 0x65, 0x36, 0x63,
	0x67, 0x78, 0x14, 0xcc, 0xd8, 0x19, 0x1e, 0xa1, 0x5d, 0x48, 0x0f, 0x35, 0x73, 0x10, 0xf4, 0xb2,
	0x74, 0xe9, 0x31, 0x10, 0xc5, 0x33, 0x78, 0x90, 0xd8, 0x15, 0xa4, 0x53, 0x58, 0x0c, 0x5b, 0xf4,
	0xef, 0xcd, 0xd2, 0xbf, 0x26, 0x67, 0x49, 0x9c, 0xee, 0xb9, 0x60, 0x18, 0x3e, 0x80, 0x6b, 0x75,
	0x4c, 0xbb, 0x93, 0x37, 0x67, 0xd0, 0xbd, 0xf7, 0x63, 0x0a, 0x1a, 0xed, 0xde, 0xf8, 0x1a, 0x7e,
	0x2f, 0x40, 0x6e, 0xdc, 0xb1, 0x0f, 0x61, 0x5e, 0x73, 0x9c, 0x71, 0x95, 0xfc, 0x21, 0xb8, 0x19,
	0x81, 0xa9, 0x38, 0x8e, 0x69, 0x78, 0xed, 0x15, 0xda, 0x3d, 0x9a, 0x51, 0xe6, 0x34, 0xc7, 0x19,
	0xe3, 0xc8, 0x30, 0x7f, 0xb6, 0x4b, 0x22, 0x38, 0x5e, 0x62, 0xeb, 0x11, 0x9c, 0x27, 0x83, 0x1e,
	0x76, 0x2d, 0x4c, 0x31, 0x99, 0x80, 0x39, 0xdb, 0x1d, 0xd3, 0x7b, 0x79, 0xc8, 0x85, 0x10, 0x52,
	0x0f, 0x56, 0xe2, 0x7c, 0x7b, 0xf7, 0x86, 0xd5, 0x8f, 0xde, 0x1b, 0x8c, 0x62, 0x13, 0xe3, 0xb8,
	0x76, 0x7f, 0xa0, 0xd3, 0xe0, 0xb9, 0xe2, 0x93, 0x17, 0xcf, 0x92, 0xf4, 0x53, 0x02, 0x96, 0x63,
	0x02, 0x43, 0x87, 0x91, 0x40, 0xfc, 0x92, 0x96, 0xdf, 0x9e, 0x4b, 0x1c, 0x4f, 0x19, 0x83, 0x5c,
	0xfc, 0x98, 0x92, 0x7e, 0x14, 0xe2, 0x63, 0xc8, 0x41, 0xfa, 0xa8, 0xd9, 0x96, 0x3b, 0xe2, 0x0c,
	0x9a, 0x87, 0x5c, 0xb5, 0xb1, 0x2f, 0x37, 0x3b, 0x6a, 0xbd, 0x25, 0x0a, 0x68, 0x19, 0x16, 0x9f,
	0x1c, 0xed, 0xc9, 0x6a, 0xa5, 0x5e, 0x57, 0xe4, 0x7a, 0xa5, 0xd3, 0x52, 0xc4, 0x04, 0x42, 0xb0,
	0xe0, 0x31, 0x0f, 0xf7, 0xdb, 0xb2, 0xd2, 0x95, 0x15, 0x31, 0x89, 0xae, 0xc3, 0x2a, 0xe7, 0x55,
	0x5b, 0xcd, 0x8e, 0xd2, 0x6a, 0x34, 0x64, 0x45, 0x3d, 0xa8, 0x34, 0x2b, 0x75, 0x59, 0x11, 0x53,
	0x68, 0x0e, 0xb2, 0x5c, 0x58, 0x6b, 0xb6, 0xc5, 0x34, 0x5a, 0x00, 0xe0, 0xd4, 0xa1, 0xd2, 0x7a,
	0x7a, 0x2c, 0xce, 0x86, 0x70, 0xed, 0xea, 0x23, 0xb9, 0x76, 0xd4, 0x90, 0x15, 0x31, 0x83, 0xf2,
	0x90, 0x61, 0xbc, 0x6a, 0xa7, 0x21, 0x66, 0x03, 0xa2, 0x21, 0x77, 0xc4, 0x9c, 0xf4, 0x29, 0x14,
	0xe3, 0x1a, 0xd5, 0x9f, 0x0e, 0x15, 0xd6, 0xa6, 0x5e, 0x7f, 0xec, 0x45, 0x17, 0x3d, 0x60, 0xd6,
	0xbb, 0x37, 0xe2, 0x7a, 0xf7, 0x43, 0x83, 0x9e, 0x32, 0x58, 0xa2, 0x14, 0xa7, 0x20, 0xf6, 0x46,
	0xa1, 0x92, 0xf4, 0xa5, 0x00, 0xe8, 0x4d, 0x13, 0x54, 0x9e, 0xae, 0xe2, 0x45, 0x03, 0x12, 0xa9,
	0x53, 0xcc, 0xd3, 0x36, 0xf1, 0x8e, 0x4f, 0xdb, 0xad, 0x1e, 0xc0, 0x78, 0xd3, 0xa3, 0x2b, 0xb0,
	0xc4, 0xeb, 0xa8, 0xb6, 0x5b, 0x47, 0x4a, 0x55, 0x56, 0x3b, 0xc7, 0x87, 0xb2, 0x38, 0x83, 0xb2,
	0x90, 0x7a, 0x5c, 0xe9, 0x56, 0x44, 0x01, 0x01, 0xcc, 0x1e, 0x1e, 0x77, 0x1e, 0xb5, 0x9a, 0x62,
	0x02, 0x65, 0x20, 0xd9, 0x3c, 0x3c, 0x10, 0x93, 0xec, 0xa3, 0x2e, 0x1f, 0x88, 0x29, 0x66, 0x5e,
	0x6b, 0x75, 0x9a, 0x72, 0xa7, 0xda, 0x52, 0x64, 0xe5, 0xa8, 0xd9, 0xd9, 0x3f, 0x90, 0xc5, 0xf4,
	0x56, 0x05, 0x60, 0xbc, 0x58, 0xa6, 0x7a, 0xa5, 0xd2, 0xac, 0x34, 0x8e, 0x9f, 0xed, 0x37, 0xeb,
	0x1e, 0xf8, 0xc3, 0xca, 0x7e, 0x43, 0xae, 0x89, 0x09, 0x26, 0x6a, 0x1f, 0x55, 0xab, 0xb2, 0x5c,
	0x93, 0x6b, 0x62, 0xb2, 0xfc, 0x47, 0x12, 0xf2, 0x1c, 0xc3, 0xfb, 0xef, 0x40, 0x3d, 0xc8, 0x85,
	0xaf, 0x04, 0x74, 0xfd, 0x2d, 0x8f, 0x9b, 0xe2, 0x5a, 0xbc, 0xd0, 0x2b, 0xb7, 0x54, 0xfc, 0xec,
	0xd7, 0xd7, 0x5f, 0x27, 0x56, 0xa4, 0x45, 0xf6, 0x67, 0xc3, 0x17, 0x19, 0xe1, 0x3f, 0x38, 0x0f,
	0x84, 0x2d, 0x74, 0x0c, 0x19, 0x7f, 0x77, 0xa2, 0x6b, 0x93, 0x37, 0x41, 0xe4, 0xca, 0x2f, 0x16,
	0xe3, 0x44, 0x3e, 0xfa, 0x2a, 0x47, 0x5f, 0x42, 0xd3, 0xe8, 0xe8, 0x3b, 0x81, 0x37, 0xe1, 0x45,
	0xf7, 0xdf, 0xbf, 0xff, 0xe2, 0xc5, 0xe3, 0x45, 0x70, 0xf7, 0x9d, 0xae, 0x29, 0xe9, 0x36, 0x0f,
	0xea, 0x26, 0xba, 0x11, 0x09, 0xca, 0xf4, 0x6d, 0xc6, 0xcb, 0x17, 0x7d, 0x21, 0x00, 0x7a, 0x73,
	0x4e, 0xd0, 0xad, 0x49, 0x67, 0xf1, 0xfb, 0xbe, 0x78, 0xfb, 0x12, 0x2d, 0x3f, 0x14, 0x89, 0x87,
	0xb2, 0x86, 0x8a, 0x91, 0x50, 0xa6, 0x47, 0xe7, 0xfd, 0x9f, 0x5f, 0xad, 0x0b, 0xbf, 0xbc, 0x5a,
	0x17, 0x5e, 0xbe, 0x5a, 0x17, 0xbe, 0xf9, 0x7d, 0x7d, 0x06, 0x36, 0x0c, 0xbb, 0x44, 0xa8, 0xa6,
	0x9f, 0xb9, 0xf6, 0x0b, 0xef, 0xbf, 0xb2, 0xa4, 0x39, 0x46, 0xe0, 0xb1, 0x34, 0xdc, 0x7e, 0x36,
	0xfe, 0x1f, 0x7d, 0x3a, 0xd3, 0x9b, 0xe5, 0x2a, 0x3b, 0x7f, 0x06, 0x00, 0x00, 0xff, 0xff, 0x85,
	0xfa, 0x93, 0x4c, 0xc7, 0x0e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ScanServiceClient is the client API for ScanService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConnInterface.NewStream.
type ScanServiceClient interface {
	ScanImage(ctx context.Context, in *ScanImageRequest, opts ...grpc.CallOption) (*ScanImageResponse, error)
	GetScan(ctx context.Context, in *GetScanRequest, opts ...grpc.CallOption) (*GetScanResponse, error)
	GetLanguageLevelComponents(ctx context.Context, in *GetLanguageLevelComponentsRequest, opts ...grpc.CallOption) (*GetLanguageLevelComponentsResponse, error)
	GetVulnerabilities(ctx context.Context, in *GetVulnerabilitiesRequest, opts ...grpc.CallOption) (*GetVulnerabilitiesResponse, error)
}

type scanServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewScanServiceClient(cc grpc.ClientConnInterface) ScanServiceClient {
	return &scanServiceClient{cc}
}

func (c *scanServiceClient) ScanImage(ctx context.Context, in *ScanImageRequest, opts ...grpc.CallOption) (*ScanImageResponse, error) {
	out := new(ScanImageResponse)
	err := c.cc.Invoke(ctx, "/scannerV1.ScanService/ScanImage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scanServiceClient) GetScan(ctx context.Context, in *GetScanRequest, opts ...grpc.CallOption) (*GetScanResponse, error) {
	out := new(GetScanResponse)
	err := c.cc.Invoke(ctx, "/scannerV1.ScanService/GetScan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scanServiceClient) GetLanguageLevelComponents(ctx context.Context, in *GetLanguageLevelComponentsRequest, opts ...grpc.CallOption) (*GetLanguageLevelComponentsResponse, error) {
	out := new(GetLanguageLevelComponentsResponse)
	err := c.cc.Invoke(ctx, "/scannerV1.ScanService/GetLanguageLevelComponents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scanServiceClient) GetVulnerabilities(ctx context.Context, in *GetVulnerabilitiesRequest, opts ...grpc.CallOption) (*GetVulnerabilitiesResponse, error) {
	out := new(GetVulnerabilitiesResponse)
	err := c.cc.Invoke(ctx, "/scannerV1.ScanService/GetVulnerabilities", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ScanServiceServer is the server API for ScanService service.
type ScanServiceServer interface {
	ScanImage(context.Context, *ScanImageRequest) (*ScanImageResponse, error)
	GetScan(context.Context, *GetScanRequest) (*GetScanResponse, error)
	GetLanguageLevelComponents(context.Context, *GetLanguageLevelComponentsRequest) (*GetLanguageLevelComponentsResponse, error)
	GetVulnerabilities(context.Context, *GetVulnerabilitiesRequest) (*GetVulnerabilitiesResponse, error)
}

// UnimplementedScanServiceServer can be embedded to have forward compatible implementations.
type UnimplementedScanServiceServer struct {
}

func (*UnimplementedScanServiceServer) ScanImage(ctx context.Context, req *ScanImageRequest) (*ScanImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScanImage not implemented")
}
func (*UnimplementedScanServiceServer) GetScan(ctx context.Context, req *GetScanRequest) (*GetScanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScan not implemented")
}
func (*UnimplementedScanServiceServer) GetLanguageLevelComponents(ctx context.Context, req *GetLanguageLevelComponentsRequest) (*GetLanguageLevelComponentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLanguageLevelComponents not implemented")
}
func (*UnimplementedScanServiceServer) GetVulnerabilities(ctx context.Context, req *GetVulnerabilitiesRequest) (*GetVulnerabilitiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVulnerabilities not implemented")
}

func RegisterScanServiceServer(s *grpc.Server, srv ScanServiceServer) {
	s.RegisterService(&_ScanService_serviceDesc, srv)
}

func _ScanService_ScanImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScanImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScanServiceServer).ScanImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scannerV1.ScanService/ScanImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScanServiceServer).ScanImage(ctx, req.(*ScanImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScanService_GetScan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetScanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScanServiceServer).GetScan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scannerV1.ScanService/GetScan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScanServiceServer).GetScan(ctx, req.(*GetScanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScanService_GetLanguageLevelComponents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLanguageLevelComponentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScanServiceServer).GetLanguageLevelComponents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scannerV1.ScanService/GetLanguageLevelComponents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScanServiceServer).GetLanguageLevelComponents(ctx, req.(*GetLanguageLevelComponentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScanService_GetVulnerabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVulnerabilitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScanServiceServer).GetVulnerabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scannerV1.ScanService/GetVulnerabilities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScanServiceServer).GetVulnerabilities(ctx, req.(*GetVulnerabilitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ScanService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "scannerV1.ScanService",
	HandlerType: (*ScanServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ScanImage",
			Handler:    _ScanService_ScanImage_Handler,
		},
		{
			MethodName: "GetScan",
			Handler:    _ScanService_GetScan_Handler,
		},
		{
			MethodName: "GetLanguageLevelComponents",
			Handler:    _ScanService_GetLanguageLevelComponents_Handler,
		},
		{
			MethodName: "GetVulnerabilities",
			Handler:    _ScanService_GetVulnerabilities_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "shared/api/v1/scan_service.proto",
}

func (m *Image) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Image) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Image) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Features) > 0 {
		for iNdEx := len(m.Features) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Features[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Feature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Feature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Feature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AddedByLayer) > 0 {
		i -= len(m.AddedByLayer)
		copy(dAtA[i:], m.AddedByLayer)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.AddedByLayer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FeatureType) > 0 {
		i -= len(m.FeatureType)
		copy(dAtA[i:], m.FeatureType)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.FeatureType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Vulnerabilities) > 0 {
		for iNdEx := len(m.Vulnerabilities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Vulnerabilities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Vulnerability) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vulnerability) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vulnerability) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MetadataV2 != nil {
		{
			size, err := m.MetadataV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.FixedBy) > 0 {
		i -= len(m.FixedBy)
		copy(dAtA[i:], m.FixedBy)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.FixedBy)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Link) > 0 {
		i -= len(m.Link)
		copy(dAtA[i:], m.Link)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Link)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CvssV3 != nil {
		{
			size, err := m.CvssV3.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CvssV2 != nil {
		{
			size, err := m.CvssV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.LastModifiedDateTime) > 0 {
		i -= len(m.LastModifiedDateTime)
		copy(dAtA[i:], m.LastModifiedDateTime)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.LastModifiedDateTime)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PublishedDateTime) > 0 {
		i -= len(m.PublishedDateTime)
		copy(dAtA[i:], m.PublishedDateTime)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.PublishedDateTime)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CVSSMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CVSSMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CVSSMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ImpactScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ImpactScore))))
		i--
		dAtA[i] = 0x25
	}
	if m.ExploitabilityScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ExploitabilityScore))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Score != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Score))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.Vector) > 0 {
		i -= len(m.Vector)
		copy(dAtA[i:], m.Vector)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Vector)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScanImageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanImageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanImageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Registry != nil {
		{
			size, err := m.Registry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScanImageRequest_RegistryData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanImageRequest_RegistryData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanImageRequest_RegistryData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Insecure {
		i--
		if m.Insecure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScanImageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScanImageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScanImageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintScanService(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImageSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Digest) > 0 {
		i -= len(m.Digest)
		copy(dAtA[i:], m.Digest)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Digest)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetScanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetScanRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetScanRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ImageSpec != nil {
		{
			size, err := m.ImageSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLanguageLevelComponentsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLanguageLevelComponentsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLanguageLevelComponentsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ImageSpec != nil {
		{
			size, err := m.ImageSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LanguageLevelComponent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LanguageLevelComponent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LanguageLevelComponent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Location) > 0 {
		i -= len(m.Location)
		copy(dAtA[i:], m.Location)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Location)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.SourceType != 0 {
		i = encodeVarintScanService(dAtA, i, uint64(m.SourceType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LanguageLevelComponents) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LanguageLevelComponents) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LanguageLevelComponents) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Components) > 0 {
		for iNdEx := len(m.Components) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Components[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetLanguageLevelComponentsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLanguageLevelComponentsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLanguageLevelComponentsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LayerToComponents) > 0 {
		for k := range m.LayerToComponents {
			v := m.LayerToComponents[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintScanService(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintScanService(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintScanService(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetScanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetScanResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetScanResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Image != nil {
		{
			size, err := m.Image.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintScanService(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetVulnerabilitiesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVulnerabilitiesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetVulnerabilitiesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Components) > 0 {
		for iNdEx := len(m.Components) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Components[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Component) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Component) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Component) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Component != nil {
		{
			size := m.Component.Size()
			i -= size
			if _, err := m.Component.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Component_AppComponent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Component_AppComponent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppComponent != nil {
		{
			size, err := m.AppComponent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Component_K8SComponent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Component_K8SComponent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.K8SComponent != nil {
		{
			size, err := m.K8SComponent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ApplicationComponent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplicationComponent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApplicationComponent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Product) > 0 {
		i -= len(m.Product)
		copy(dAtA[i:], m.Product)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Product)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Vendor) > 0 {
		i -= len(m.Vendor)
		copy(dAtA[i:], m.Vendor)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Vendor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KubernetesComponent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesComponent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KubernetesComponent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintScanService(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if m.Component != 0 {
		i = encodeVarintScanService(dAtA, i, uint64(m.Component))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetVulnerabilitiesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetVulnerabilitiesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetVulnerabilitiesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.VulnerabilitiesByComponent) > 0 {
		for iNdEx := len(m.VulnerabilitiesByComponent) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VulnerabilitiesByComponent[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ComponentWithVulns) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComponentWithVulns) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComponentWithVulns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Vulnerabilities) > 0 {
		for iNdEx := len(m.Vulnerabilities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Vulnerabilities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintScanService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Component != nil {
		{
			size, err := m.Component.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintScanService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintScanService(dAtA []byte, offset int, v uint64) int {
	offset -= sovScanService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Image) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Features) > 0 {
		for _, e := range m.Features {
			l = e.Size()
			n += 1 + l + sovScanService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Feature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	if len(m.Vulnerabilities) > 0 {
		for _, e := range m.Vulnerabilities {
			l = e.Size()
			n += 1 + l + sovScanService(uint64(l))
		}
	}
	l = len(m.FeatureType)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	l = len(m.AddedByLayer)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vulnerability) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	l = len(m.FixedBy)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.MetadataV2 != nil {
		l = m.MetadataV2.Size()
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublishedDateTime)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	l = len(m.LastModifiedDateTime)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.CvssV2 != nil {
		l = m.CvssV2.Size()
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.CvssV3 != nil {
		l = m.CvssV3.Size()
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CVSSMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Vector)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.Score != 0 {
		n += 5
	}
	if m.ExploitabilityScore != 0 {
		n += 5
	}
	if m.ImpactScore != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScanImageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.Registry != nil {
		l = m.Registry.Size()
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScanImageRequest_RegistryData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.Insecure {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScanImageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovScanService(uint64(m.Status))
	}
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ImageSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetScanRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImageSpec != nil {
		l = m.ImageSpec.Size()
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLanguageLevelComponentsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImageSpec != nil {
		l = m.ImageSpec.Size()
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LanguageLevelComponent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourceType != 0 {
		n += 1 + sovScanService(uint64(m.SourceType))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LanguageLevelComponents) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Components) > 0 {
		for _, e := range m.Components {
			l = e.Size()
			n += 1 + l + sovScanService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLanguageLevelComponentsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LayerToComponents) > 0 {
		for k, v := range m.LayerToComponents {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovScanService(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovScanService(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovScanService(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetScanResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovScanService(uint64(m.Status))
	}
	if m.Image != nil {
		l = m.Image.Size()
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetVulnerabilitiesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Components) > 0 {
		for _, e := range m.Components {
			l = e.Size()
			n += 1 + l + sovScanService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Component) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Component != nil {
		n += m.Component.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Component_AppComponent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppComponent != nil {
		l = m.AppComponent.Size()
		n += 1 + l + sovScanService(uint64(l))
	}
	return n
}
func (m *Component_K8SComponent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.K8SComponent != nil {
		l = m.K8SComponent.Size()
		n += 1 + l + sovScanService(uint64(l))
	}
	return n
}
func (m *ApplicationComponent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	l = len(m.Product)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesComponent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Component != 0 {
		n += 1 + sovScanService(uint64(m.Component))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovScanService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetVulnerabilitiesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.VulnerabilitiesByComponent) > 0 {
		for _, e := range m.VulnerabilitiesByComponent {
			l = e.Size()
			n += 1 + l + sovScanService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComponentWithVulns) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Component != nil {
		l = m.Component.Size()
		n += 1 + l + sovScanService(uint64(l))
	}
	if len(m.Vulnerabilities) > 0 {
		for _, e := range m.Vulnerabilities {
			l = e.Size()
			n += 1 + l + sovScanService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovScanService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozScanService(x uint64) (n int) {
	return sovScanService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Image) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Image: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Image: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Features = append(m.Features, &Feature{})
			if err := m.Features[len(m.Features)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Feature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Feature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Feature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vulnerabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vulnerabilities = append(m.Vulnerabilities, &Vulnerability{})
			if err := m.Vulnerabilities[len(m.Vulnerabilities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeatureType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedByLayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddedByLayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vulnerability) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vulnerability: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vulnerability: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FixedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FixedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MetadataV2 == nil {
				m.MetadataV2 = &Metadata{}
			}
			if err := m.MetadataV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishedDateTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublishedDateTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModifiedDateTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastModifiedDateTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CvssV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CvssV2 == nil {
				m.CvssV2 = &CVSSMetadata{}
			}
			if err := m.CvssV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CvssV3", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CvssV3 == nil {
				m.CvssV3 = &CVSSMetadata{}
			}
			if err := m.CvssV3.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CVSSMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CVSSMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CVSSMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vector = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Score = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExploitabilityScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ExploitabilityScore = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImpactScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ImpactScore = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanImageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanImageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanImageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Registry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Registry == nil {
				m.Registry = &ScanImageRequest_RegistryData{}
			}
			if err := m.Registry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanImageRequest_RegistryData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegistryData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegistryData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Insecure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Insecure = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanImageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanImageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanImageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ScanStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &ImageSpec{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetScanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetScanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetScanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageSpec == nil {
				m.ImageSpec = &ImageSpec{}
			}
			if err := m.ImageSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLanguageLevelComponentsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLanguageLevelComponentsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLanguageLevelComponentsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageSpec == nil {
				m.ImageSpec = &ImageSpec{}
			}
			if err := m.ImageSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LanguageLevelComponent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LanguageLevelComponent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LanguageLevelComponent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceType", wireType)
			}
			m.SourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceType |= SourceType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LanguageLevelComponents) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LanguageLevelComponents: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LanguageLevelComponents: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Components = append(m.Components, &LanguageLevelComponent{})
			if err := m.Components[len(m.Components)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLanguageLevelComponentsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLanguageLevelComponentsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLanguageLevelComponentsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LayerToComponents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LayerToComponents == nil {
				m.LayerToComponents = make(map[string]*LanguageLevelComponents)
			}
			var mapkey string
			var mapvalue *LanguageLevelComponents
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowScanService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScanService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthScanService
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthScanService
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowScanService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthScanService
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthScanService
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &LanguageLevelComponents{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipScanService(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthScanService
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.LayerToComponents[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetScanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetScanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetScanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ScanStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Image == nil {
				m.Image = &Image{}
			}
			if err := m.Image.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVulnerabilitiesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVulnerabilitiesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVulnerabilitiesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Components = append(m.Components, &Component{})
			if err := m.Components[len(m.Components)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Component) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Component: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Component: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppComponent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ApplicationComponent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Component = &Component_AppComponent{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field K8SComponent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KubernetesComponent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Component = &Component_K8SComponent{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplicationComponent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplicationComponent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplicationComponent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Product", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Product = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesComponent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesComponent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesComponent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Component", wireType)
			}
			m.Component = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Component |= KubernetesComponent_KubernetesComponent(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetVulnerabilitiesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetVulnerabilitiesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetVulnerabilitiesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VulnerabilitiesByComponent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VulnerabilitiesByComponent = append(m.VulnerabilitiesByComponent, &ComponentWithVulns{})
			if err := m.VulnerabilitiesByComponent[len(m.VulnerabilitiesByComponent)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComponentWithVulns) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComponentWithVulns: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComponentWithVulns: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Component", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Component == nil {
				m.Component = &Component{}
			}
			if err := m.Component.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vulnerabilities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthScanService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthScanService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vulnerabilities = append(m.Vulnerabilities, &Vulnerability{})
			if err := m.Vulnerabilities[len(m.Vulnerabilities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipScanService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthScanService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipScanService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowScanService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowScanService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthScanService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupScanService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthScanService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthScanService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowScanService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupScanService = fmt.Errorf("proto: unexpected end of group")
)
